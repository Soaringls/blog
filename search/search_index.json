{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to my blog \u00b6 I'm dexter , an algorithm engineer focusing on Mapping&Localization of self-driving technique. This is the website I used to take notes while learning or working. More about me: Email Github","title":"Home"},{"location":"#welcome-to-my-blog","text":"I'm dexter , an algorithm engineer focusing on Mapping&Localization of self-driving technique. This is the website I used to take notes while learning or working. More about me: Email Github","title":"Welcome to my blog"},{"location":"coding/coding_work_style/","text":"Code Style \u00b6 install cpplint by pip install cpplint and pylint by pip install pylint to find bugs and style problems in c++/python source the reference is Google Style Guide Abseil Libs \u00b6 C++ and Python developer Guide from Abseil Code Review \u00b6 \u76ee\u7684 \u00b6 \u628a\u63a7\u8d28\u91cf \u4f20\u9012\u77e5\u8bc6\u548c\u7ec6\u8282 \u5185\u5bb9 \u00b6 \u6574\u4f53\u8bbe\u8ba1: \u8bbe\u8ba1\u662f\u5426\u5408\u7406 \u529f\u80fd\u5b9e\u73b0: \u662f\u5426\u5b9e\u73b0\u9884\u671f\u529f\u80fd,\u662f\u5426\u7ecf\u8fc7\u76f8\u5173\u5145\u5206\u6d4b\u8bd5 \u590d\u6742\u5ea6:\u8bbe\u8ba1\u548c\u5b9e\u73b0\u8fd8\u80fd\u5426\u7b80\u5316,\u662f\u5426\u5b58\u5728\u91cd\u590d\u6027\u4ee3\u7801 \u4ee3\u7801\u6027\u80fd:\u662f\u5426\u6709\u660e\u663e\u7684\u6027\u80fd\u95ee\u9898,\u662f\u5426\u53ef\u4ee5\u660e\u663e\u7684\u53ef\u4ee5\u4f18\u5316 \u6d4b\u8bd5:\u662f\u5426\u6709\u76f8\u5173\u5355\u5143\u6d4b\u8bd5,\u6d4b\u8bd5\u662f\u5426\u5408\u7406 \u547d\u540d:\u662f\u5426\u6e05\u6670\u6613\u61c2 \u6ce8\u91ca:\u5fc5\u8981\u7684\u6ce8\u91ca\u662f\u5426\u6709\u7f3a\u5931 \u4ee3\u7801\u98ce\u683c:\u98ce\u683c\u662f\u5426\u548c\u5df2\u6709\u7684\u4e00\u81f4 \u6587\u6863\u66f4\u65b0:\u76f8\u5173\u6587\u6863\u662f\u5426\u66f4\u65b0 \u57fa\u672c\u539f\u5219 \u00b6 \u9009\u53d6\u5408\u9002\u7684reviewer,\u5fc5\u8981\u65f6\u9009\u53d6\u8d44\u6df1\u7684reviewer \u53ef\u4ee5\u8bfb\u4e2areviewer\u68c0\u67e5\u591a\u4e2a\u90e8\u5206 TL\u5e2e\u52a9\u65b0\u540c\u4e8b\u52a0\u5f3a\u4ee3\u7801\u98ce\u683c\u548c\u8bbe\u8ba1\u539f\u5219 \u8d28\u91cf\u548c\u8fdb\u5ea6\u90fd\u5f88\u91cd\u8981,\u6ca1\u6709\u5b8c\u7f8e\u7684mr,\u5982\u679c\u6574\u4f53\u6539\u8fdb\u4e86\u4ee3\u7801\u8d28\u91cf\u53ef\u4ee5\u8003\u8651approve \u54cd\u5e94\u901f\u5ea6\u5f88\u91cd\uff01 \u4e00\u4e2a\u5de5\u4f5c\u65e5\u5185\u54cd\u5e94 \u59cb\u7ec8\u9075\u5b88\u4ee3\u7801\u98ce\u683c\u6307\u5bfc,\u51cf\u5c11\u7eb7\u4e89 MR\u7684\u51c6\u5907 \u00b6 \u5c3d\u91cf\u5199\u76f8\u5bf9\u8f83\u5c0f\u7684mr,\u907f\u514d\u5927\u7684mr \u66f4\u5bb9\u6613review \u66f4\u5bb9\u6613\u5408\u5165\u548c\u56de\u6eda \u66f4\u5bb9\u6613\u8bbe\u8ba1 \u66f4\u4e0d\u5bb9\u6613\u51fa\u9519 \u628a\u4ee3\u7801\u91cd\u6784\u7684\u4fee\u6539\u62c6\u51fa\u6765 MR/commit\u7684\u63cf\u8ff0\u8981\u89c4\u8303 \u7b2c\u4e00\u884c\u505a\u6574\u4f53\u6e05\u6670\u7684\u63cf\u8ff0 \u4e3b\u4f53\u6709\u8db3\u591f\u7684\u4fe1\u606f\u91cf \u63d0\u4ea4review\u524d\u4fdd\u8bc1mr\u7684\u5065\u5eb7\u5ea6 Onboardd\u4ee3\u7801\u7684\u65b0\u529f\u80fd\u5982\u679c\u5b58\u5728\u98ce\u9669,\u53ef\u4ee5\u7528flag\u4fdd\u62a4\u8d77\u6765 \u5173\u4e8eReview \u00b6 \u68c0\u67e5\u6bcf\u4e00\u884c\u4ee3\u7801 \u591a\u65b9\u9762\u5ba1\u67e5\u4ee3\u7801(\u53c2\u8003\u5185\u5bb9) \u54cd\u5e94\u8981\u53ca\u65f6,\u80fd\u89e3\u51b3\u5f88\u591a\u95ee\u9898 Be kind,\u8bc4\u8bba\u9488\u5bf9\u4ee3\u7801\u4e0d\u9488\u4eba \u6709\u5927\u7684\u4e89\u8bae\u8981\u53ca\u65f6\u6c9f\u901a,\u5305\u62ec\u7ebf\u4e0b\u6c9f\u901a,\u82e5\u672a\u80fd\u89e3\u51b3\u7531\u4e0a\u7ea7\u4ef2\u88c1 \u7a0d\u540e\u6e05\u7406\uff1f \u8981\u9a6c\u4e0a\u6e05\u7406 \u65e0\u4f24\u5927\u96c5\u7684\u5efa\u8bae? Nit:/ comment / \u5173\u4e8e\u6027\u80fd\u4f18\u5316 \u00b6 \u5e94\u8be5\u575a\u6301\u7684\u4f18\u5316: \u7b97\u6cd5\u590d\u6742\u5ea6\u4f18\u5316 \u987a\u624b\u505a\u7684\u4f18\u5316 \u6570\u636e\u7ed3\u6784\u7684\u9009\u53d6 \u907f\u514d\u4e0d\u5fc5\u8981\u7684\u62f7\u8d1d \u4efb\u4f55\u5176\u4ed6\u4e0d\u589e\u52a0\u590d\u6742\u5ea6\u4e0d\u5f71\u54cd\u6027\u80fd\u548c\u53ef\u8bfb\u6027\u7684\u4f18\u5316 \u53ef\u80fd\u9700\u8981\u907f\u514d\u7684\u4f18\u5316: \u8fc7\u65e9\u7684\u4f24\u5bb3\u4ee3\u7801\u53ef\u8bfb\u6027\u7ef4\u62a4\u6027\u7684\u4f18\u5316 \u5bf9\u6574\u4f53\u6027\u80fd\u5e2e\u52a9\u4e0d\u5927\u7684\u590d\u6742\u4f18\u5316 \u6027\u80fd\u654f\u611f\u7684\u51fd\u6570/\u5b50\u6a21\u5757\u6700\u597d\u52a0benchmark\u8ddf\u8e2a\u8d77\u6765 \u95ee\u7b54Q&A \u00b6","title":"Coding work style"},{"location":"coding/coding_work_style/#code-style","text":"install cpplint by pip install cpplint and pylint by pip install pylint to find bugs and style problems in c++/python source the reference is Google Style Guide","title":"Code Style"},{"location":"coding/coding_work_style/#abseil-libs","text":"C++ and Python developer Guide from Abseil","title":"Abseil Libs"},{"location":"coding/coding_work_style/#code-review","text":"","title":"Code Review"},{"location":"coding/coding_work_style/#_1","text":"\u628a\u63a7\u8d28\u91cf \u4f20\u9012\u77e5\u8bc6\u548c\u7ec6\u8282","title":"\u76ee\u7684"},{"location":"coding/coding_work_style/#_2","text":"\u6574\u4f53\u8bbe\u8ba1: \u8bbe\u8ba1\u662f\u5426\u5408\u7406 \u529f\u80fd\u5b9e\u73b0: \u662f\u5426\u5b9e\u73b0\u9884\u671f\u529f\u80fd,\u662f\u5426\u7ecf\u8fc7\u76f8\u5173\u5145\u5206\u6d4b\u8bd5 \u590d\u6742\u5ea6:\u8bbe\u8ba1\u548c\u5b9e\u73b0\u8fd8\u80fd\u5426\u7b80\u5316,\u662f\u5426\u5b58\u5728\u91cd\u590d\u6027\u4ee3\u7801 \u4ee3\u7801\u6027\u80fd:\u662f\u5426\u6709\u660e\u663e\u7684\u6027\u80fd\u95ee\u9898,\u662f\u5426\u53ef\u4ee5\u660e\u663e\u7684\u53ef\u4ee5\u4f18\u5316 \u6d4b\u8bd5:\u662f\u5426\u6709\u76f8\u5173\u5355\u5143\u6d4b\u8bd5,\u6d4b\u8bd5\u662f\u5426\u5408\u7406 \u547d\u540d:\u662f\u5426\u6e05\u6670\u6613\u61c2 \u6ce8\u91ca:\u5fc5\u8981\u7684\u6ce8\u91ca\u662f\u5426\u6709\u7f3a\u5931 \u4ee3\u7801\u98ce\u683c:\u98ce\u683c\u662f\u5426\u548c\u5df2\u6709\u7684\u4e00\u81f4 \u6587\u6863\u66f4\u65b0:\u76f8\u5173\u6587\u6863\u662f\u5426\u66f4\u65b0","title":"\u5185\u5bb9"},{"location":"coding/coding_work_style/#_3","text":"\u9009\u53d6\u5408\u9002\u7684reviewer,\u5fc5\u8981\u65f6\u9009\u53d6\u8d44\u6df1\u7684reviewer \u53ef\u4ee5\u8bfb\u4e2areviewer\u68c0\u67e5\u591a\u4e2a\u90e8\u5206 TL\u5e2e\u52a9\u65b0\u540c\u4e8b\u52a0\u5f3a\u4ee3\u7801\u98ce\u683c\u548c\u8bbe\u8ba1\u539f\u5219 \u8d28\u91cf\u548c\u8fdb\u5ea6\u90fd\u5f88\u91cd\u8981,\u6ca1\u6709\u5b8c\u7f8e\u7684mr,\u5982\u679c\u6574\u4f53\u6539\u8fdb\u4e86\u4ee3\u7801\u8d28\u91cf\u53ef\u4ee5\u8003\u8651approve \u54cd\u5e94\u901f\u5ea6\u5f88\u91cd\uff01 \u4e00\u4e2a\u5de5\u4f5c\u65e5\u5185\u54cd\u5e94 \u59cb\u7ec8\u9075\u5b88\u4ee3\u7801\u98ce\u683c\u6307\u5bfc,\u51cf\u5c11\u7eb7\u4e89","title":"\u57fa\u672c\u539f\u5219"},{"location":"coding/coding_work_style/#mr","text":"\u5c3d\u91cf\u5199\u76f8\u5bf9\u8f83\u5c0f\u7684mr,\u907f\u514d\u5927\u7684mr \u66f4\u5bb9\u6613review \u66f4\u5bb9\u6613\u5408\u5165\u548c\u56de\u6eda \u66f4\u5bb9\u6613\u8bbe\u8ba1 \u66f4\u4e0d\u5bb9\u6613\u51fa\u9519 \u628a\u4ee3\u7801\u91cd\u6784\u7684\u4fee\u6539\u62c6\u51fa\u6765 MR/commit\u7684\u63cf\u8ff0\u8981\u89c4\u8303 \u7b2c\u4e00\u884c\u505a\u6574\u4f53\u6e05\u6670\u7684\u63cf\u8ff0 \u4e3b\u4f53\u6709\u8db3\u591f\u7684\u4fe1\u606f\u91cf \u63d0\u4ea4review\u524d\u4fdd\u8bc1mr\u7684\u5065\u5eb7\u5ea6 Onboardd\u4ee3\u7801\u7684\u65b0\u529f\u80fd\u5982\u679c\u5b58\u5728\u98ce\u9669,\u53ef\u4ee5\u7528flag\u4fdd\u62a4\u8d77\u6765","title":"MR\u7684\u51c6\u5907"},{"location":"coding/coding_work_style/#review","text":"\u68c0\u67e5\u6bcf\u4e00\u884c\u4ee3\u7801 \u591a\u65b9\u9762\u5ba1\u67e5\u4ee3\u7801(\u53c2\u8003\u5185\u5bb9) \u54cd\u5e94\u8981\u53ca\u65f6,\u80fd\u89e3\u51b3\u5f88\u591a\u95ee\u9898 Be kind,\u8bc4\u8bba\u9488\u5bf9\u4ee3\u7801\u4e0d\u9488\u4eba \u6709\u5927\u7684\u4e89\u8bae\u8981\u53ca\u65f6\u6c9f\u901a,\u5305\u62ec\u7ebf\u4e0b\u6c9f\u901a,\u82e5\u672a\u80fd\u89e3\u51b3\u7531\u4e0a\u7ea7\u4ef2\u88c1 \u7a0d\u540e\u6e05\u7406\uff1f \u8981\u9a6c\u4e0a\u6e05\u7406 \u65e0\u4f24\u5927\u96c5\u7684\u5efa\u8bae? Nit:/ comment /","title":"\u5173\u4e8eReview"},{"location":"coding/coding_work_style/#_4","text":"\u5e94\u8be5\u575a\u6301\u7684\u4f18\u5316: \u7b97\u6cd5\u590d\u6742\u5ea6\u4f18\u5316 \u987a\u624b\u505a\u7684\u4f18\u5316 \u6570\u636e\u7ed3\u6784\u7684\u9009\u53d6 \u907f\u514d\u4e0d\u5fc5\u8981\u7684\u62f7\u8d1d \u4efb\u4f55\u5176\u4ed6\u4e0d\u589e\u52a0\u590d\u6742\u5ea6\u4e0d\u5f71\u54cd\u6027\u80fd\u548c\u53ef\u8bfb\u6027\u7684\u4f18\u5316 \u53ef\u80fd\u9700\u8981\u907f\u514d\u7684\u4f18\u5316: \u8fc7\u65e9\u7684\u4f24\u5bb3\u4ee3\u7801\u53ef\u8bfb\u6027\u7ef4\u62a4\u6027\u7684\u4f18\u5316 \u5bf9\u6574\u4f53\u6027\u80fd\u5e2e\u52a9\u4e0d\u5927\u7684\u590d\u6742\u4f18\u5316 \u6027\u80fd\u654f\u611f\u7684\u51fd\u6570/\u5b50\u6a21\u5757\u6700\u597d\u52a0benchmark\u8ddf\u8e2a\u8d77\u6765","title":"\u5173\u4e8e\u6027\u80fd\u4f18\u5316"},{"location":"coding/coding_work_style/#qa","text":"","title":"\u95ee\u7b54Q&amp;A"},{"location":"coding/c%2B%2B/cpp_17/","text":"C++17 \u65b0\u7279\u6027 \u00b6 \u6784\u9020\u51fd\u6570\u6a21\u677f\u63a8\u5bfc \u00b6 Automatic template argument deduction much like how it's done for functions, but now including class constructors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //eg.1 template < typename T = float > struct MyContainer { T val_ ; MyContainer () : val_ {}{} MyContainer ( T val ) : val_ ( val ){} //... }; MyContainer c1 { 1 }; // type->int MyContainer c2 ; // type->float,default //eg.2 std :: pair < int , double > p ( 1 , 2.2 ); //before 17 std :: pair p ( 1 , 2.2 ); //now, \u81ea\u52a8\u63a8\u5bfc std :: vector v = { 1 , 2 , 3 }; //now Declaring non-type template parameters with auto \u00b6 Following the deduction rules of auto , while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the type ot its arguments: 1 2 3 4 5 6 7 8 9 template < auto ... seq > struct my_integer_sequence { // Implementation here ... }; // Explicitly pass type `int` as template argument. auto seq = std :: integer_sequence < int , 0 , 1 , 2 > (); // Type is deduced to be `int`. auto seq2 = my_integer_sequence < 0 , 1 , 2 > (); Folding expressions \u00b6 A fold expression performs a fold of a template parameter pack over a binary operator. An expression of the form (... op e) or (e op ...) , where op is a fold-operator and e is an unexpanded parameter pack, are called unary folds. An expression of the form (e1 op ... op e2) , where op are fold-operators, is called a binary fold. Either e1 or e2 is an unexpanded parameter pack, but not both. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename ... Args > bool logicalAnd ( Args ... args ) { // Binary folding. return ( true && ... && args ); } bool b = true ; bool & b2 = b ; logicalAnd ( b , b2 , true ); // == true template < typename ... Args > auto sum ( Args ... args ) { // Unary folding. return (... + args ); } sum ( 1.0 , 2.0f , 3 ); // == 6.0 New rules for auto deduction from braced-init-list \u00b6 Changes to auto deduction when used with the uniform initialization syntax. Previously, auto x {3} deduced a std::initializer_list<int> , which now deduces to int . 1 2 3 4 auto x1 { 1 , 2 , 3 }; // error: not a single element. auto x2 = { 1 , 2 , 3 }; // x2 is std::initializer_list<int> auto x3 { 3 }; // x3 is int auto x4 { 3.0 }; // x4 is double constexpr lambda \u00b6 Compile-time lambda using constexpr . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto identity = []( int n ) constexpr { return n ; }; static_assert ( identity ( 123 ) == 123 ); constexpr auto add = []( int x , int y ) { auto L = [ = ] { return x ; }; auto R = [ = ] { return y ; }; return [ = ] { return L () + R (); }; }; static_assert ( add ( 1 , 2 )() == 3 ); constexpr int addOne ( int n ) { return [ n ] { return n + 1 ; }(); } static_assert ( addOne ( 1 ) == 2 ); Lambda capture this by value \u00b6 Capturing this in a lambda's environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. *this (C++17) will now make a copy of the current object, while this (C++11) continues to capture by reference. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct MyObj { int value { 123 }; auto getValueCopy () { return [ * this ] { return value ; }; } auto getValueRef () { return [ this ] { return value ; }; } }; MyObj mo ; auto valueCopy = mo . getValueCopy (); auto valueRef = mo . getValueRef (); mo . value = 321 ; valueCopy (); // 123 valueRef (); // 321 Inline variables \u00b6 The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline. 1 2 3 4 5 6 7 8 // Disassembly example using compiler explorer. struct S { int x ; }; inline S x1 = S { 321 }; // mov esi, dword ptr [x1] // x1: .long 321 S x2 = S { 123 }; // mov eax, dword ptr [.L_ZZ4mainE2x2] // mov dword ptr [rbp - 8], eax // .L_ZZ4mainE2x2: .long 123 It can also be used to declare and define a static member variable, such that it does not need to be initialized in the source file. 1 2 3 4 5 6 struct S { S () : id { count ++ } {} ~ S () { count -- ; } int id ; static inline int count { 0 }; // declare and initialize count to 0 within the class }; Nested namespaces \u00b6 Using the namespace resolution operator to create nested namespace definitions. 1 2 3 4 5 6 7 8 9 10 11 namespace A { namespace B { namespace C { int i ; } } } // vs. namespace A :: B :: C { int i ; } Structured bindings \u00b6 A proposal for de-structuring initialization, that would allow writting auto [ x, y, z] = expr; where the type of expr was a tuple-like object, whose elements would be bound to the variables x , y and z (which is construc declares). tuple-like objects include std::tuple , std::pair , std::array , and aggregate structures. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using Coordinate = std :: pair < int , int > ; Coordinate origin () { return Coordinate { 0 , 0 }; } const auto [ x , y ] = origin (); x ; // == 0 y ; // == 0 std :: unordered_map < std :: string , int > mapping { { \"a\" , 1 }, { \"b\" , 2 }, { \"c\" , 3 } }; // Destructure by reference. for ( const auto & [ key , value ] : mapping ) { // Do something with key and value } Selection statements with initializer \u00b6 New version of if and switch statements which simplify code patterns and help users keep scopes tight. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { std :: lock_guard < std :: mutex > lk ( mx ); if ( v . empty ()) v . push_back ( val ); } // vs. if ( std :: lock_guard < std :: mutex > lk ( mx ); v . empty ()) { v . push_back ( val ); } Foo gadget ( args ); switch ( auto s = gadget . status ()) { case OK : gadget . zip (); break ; case Bad : throw BadFoo ( s . message ()); } // vs. switch ( Foo gadget ( args ); auto s = gadget . status ()) { case OK : gadget . zip (); break ; case Bad : throw BadFoo ( s . message ()); } constexpr if \u00b6 Write code that is instantiated depending on a compile=time condition. 1 2 3 4 5 6 7 8 9 10 11 12 13 template < typename T > constexpr bool isIntegral () { if constexpr ( std :: is_integral < T >:: value ) { return true ; } else { return false ; } } static_assert ( isIntegral < int > () == true ); static_assert ( isIntegral < char > () == true ); static_assert ( isIntegral < double > () == false ); struct S {}; static_assert ( isIntegral < S > () == false ); UTF-8 character literals \u00b6 A character literal that begins with u8 is a character literal of type char . The value of a UTF-8 character literal is equal to its ISO 10646 code point value. 1 char x = u8 'x' ; Direct list initialization of enums \u00b6 Enums can now be initialized using braced syntax. 1 2 3 4 5 enum byte : unsigned char {}; byte b { 0 }; // OK byte c { -1 }; // ERROR byte d = byte { 1 }; // OK byte e = byte { 256 }; // ERROR fallthrough, nodiscard, maybe_unused attributes \u00b6 C++17 introduces threee new attributes: [[fallthrough]] : indicates to the compiler that falling through in a switch statement is intended behavior. 1 2 3 4 5 6 7 switch ( n ) { case 1 : [[ fallthrough ]] // ... case 2 : // ... break ; } [[nodiscard]] : issues a warning when either a function or class has this attribute and its return value is discarded. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [[ nodiscard ]] bool do_something () { return is_success ; // true for success, false for failure } do_something (); // warning: ignoring return value of 'bool do_something()', // declared with attribute 'nodiscard' // Only issues a warning when `error_info` is returned by value. struct [[ nodiscard ]] error_info { // ... }; error_info do_something () { error_info ei ; // ... return ei ; } do_something (); // warning: ignoring returned value of type 'error_info', // declared with attribute 'nodiscard' [[maybe_unused]] : indicates to be compiler that a variable or parameter might be unused an is intended. 1 2 3 4 void my_callback ( std :: string msg , [[ maybe_unused ]] bool error ) { // Don't care if `msg` is an error message, just log it. log ( msg ); } C++17 New Libraries \u00b6 std::variant \u00b6 The class template std::variant represents a type-safe union . An instance of std::variant at any given time holds a value of one of its alternativqe types(it's possible for it to be valueless). 1 2 3 4 5 6 std :: variant < int , double > v { 12 }; std :: get < int > ( v ); // == 12 std :: get < 0 > ( v ); // == 12 v = 12.0 ; std :: get < double > ( v ); // == 12.0 std :: get < 1 > ( v ); // == 12.0 std::optional \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 std :: optional < std :: string > create ( bool b ) { if ( b ) { return \"Godzilla\" ; } else { return {}; } } create ( false ). value_or ( \"empty\" ); // == \"empty\" create ( true ). value (); // == \"Godzilla\" // optional-returning factory functions are usable as conditions of while and if if ( auto str = create ( true )) { // ... } std::any \u00b6 A type-safe container for single values of any type. 1 2 3 4 5 std :: any x { 5 }; x . has_value () // == true std :: any_cast < int > ( x ) // == 5 std :: any_cast < int &> ( x ) = 10 ; std :: any_cast < int > ( x ) // == 10 std::string_view \u00b6 A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing). 1 2 3 4 5 6 7 8 9 10 11 12 13 // Regular strings. std :: string_view cppstr { \"foo\" }; // Wide strings. std :: wstring_view wcstr_v { L \"baz\" }; // Character arrays. char array [ 3 ] = { 'b' , 'a' , 'r' }; std :: string_view array_v ( array , std :: size ( array )); std :: string str { \" trim me\" }; std :: string_view v { str }; v . remove_prefix ( std :: min ( v . find_first_not_of ( \" \" ), v . size ())); str ; // == \" trim me\" v ; // == \"trim me\" std::invoke \u00b6 Invoke a Callable object with parameters. Examples of Callable objects are std::function or std::bind where an object can be called similarly to a regular function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template < typename Callable > class Proxy { Callable c ; public : Proxy ( Callable c ) : c ( c ) {} template < class ... Args > decltype ( auto ) operator ()( Args && ... args ) { // ... return std :: invoke ( c , std :: forward < Args > ( args )...); } }; auto add = []( int x , int y ) { return x + y ; }; Proxy < decltype ( add ) > p { add }; p ( 1 , 2 ); // == 3 std::apply \u00b6 Invoke a Callable object with a tuple of arguments 1 2 3 4 auto add = []( int x , int y ) { return x + y ; }; std :: apply ( add , std :: make_tuple ( 1 , 2 )); // == 3 std::filesystem \u00b6 The new std::filesystem library provides a standard way to manipulate files, directories, and paths in a filesystem. 1 2 3 4 5 6 7 8 9 const auto bigFilePath { \"bigFileToCopy\" }; if ( std :: filesystem :: exists ( bigFilePath )) { const auto bigFileSize { std :: filesystem :: file_size ( bigFilePath )}; std :: filesystem :: path tmpPath { \"/tmp\" }; if ( std :: filesystem :: space ( tmpPath ). available > bigFileSize ) { std :: filesystem :: create_directory ( tmpPath . append ( \"example\" )); std :: filesystem :: copy_file ( bigFilePath , tmpPath . append ( \"newFile\" )); } } std::byte \u00b6 The new std::byte type provides a standard way of representing data as byte. Benefits of using std::byte over char or unsigned char is that it is not a character type, and is also not an arithmetic type; while the only operator overloads available are bitwise operator. 1 2 3 4 5 std :: byte a { 0 }; std :: byte b { 0xFF }; int i = std :: to_integer < int > ( b ); // 0xFF std :: byte c = a & b ; int j = std :: to_integer < int > ( c ); // 0 Splicing for maps and sets \u00b6 Moving nodes and merging containers whithout the overhead of expensive copies, moves, or heap allocations/deallocations. Moving elements from one map to another: 1 2 3 4 5 std :: map < int , string > src {{ 1 , \"one\" }, { 2 , \"two\" }, { 3 , \"buckle my shoe\" }}; std :: map < int , string > dst {{ 3 , \"three\" }}; dst . insert ( src . extract ( src . find ( 1 ))); // Cheap remove and insert of { 1, \"one\" } from `src` to `dst`. dst . insert ( src . extract ( 2 )); // Cheap remove and insert of { 2, \"two\" } from `src` to `dst`. // dst == { { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } }; Inserting elements which outlive the container: 1 2 3 4 5 6 auto elementFactory () { std :: set < ... > s ; s . emplace (...); return s . extract ( s . begin ()); } s2 . insert ( elementFactory ()); Changing the key of a map element: 1 2 3 4 5 std :: map < int , string > m {{ 1 , \"one\" }, { 2 , \"two\" }, { 3 , \"three\" }}; auto e = m . extract ( 2 ); e . key () = 4 ; m . insert ( std :: move ( e )); // m == { { 1, \"one\" }, { 3, \"three\" }, { 4, \"two\" } } parallel algorithms \u00b6 Many of the STL algorithms, such as the copy , find and sort methods, started to support the parallel execution policies: seq , par and par_unseq which translate to \"sequentially\", \"parallel\" and \"parallel unsequenced\". 1 2 3 4 5 std :: vector < int > longVector ; // Find element using parallel execution policy auto result1 = std :: find ( std :: execution :: par , std :: begin ( longVector ), std :: end ( longVector ), 2 ); // Sort elements using sequential execution policy auto result2 = std :: sort ( std :: execution :: seq , std :: begin ( longVector ), std :: end ( longVector ));","title":"C++17 \u65b0\u7279\u6027"},{"location":"coding/c%2B%2B/cpp_17/#c17","text":"","title":"C++17 \u65b0\u7279\u6027"},{"location":"coding/c%2B%2B/cpp_17/#_1","text":"Automatic template argument deduction much like how it's done for functions, but now including class constructors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //eg.1 template < typename T = float > struct MyContainer { T val_ ; MyContainer () : val_ {}{} MyContainer ( T val ) : val_ ( val ){} //... }; MyContainer c1 { 1 }; // type->int MyContainer c2 ; // type->float,default //eg.2 std :: pair < int , double > p ( 1 , 2.2 ); //before 17 std :: pair p ( 1 , 2.2 ); //now, \u81ea\u52a8\u63a8\u5bfc std :: vector v = { 1 , 2 , 3 }; //now","title":"\u6784\u9020\u51fd\u6570\u6a21\u677f\u63a8\u5bfc"},{"location":"coding/c%2B%2B/cpp_17/#declaring-non-type-template-parameters-with-auto","text":"Following the deduction rules of auto , while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the type ot its arguments: 1 2 3 4 5 6 7 8 9 template < auto ... seq > struct my_integer_sequence { // Implementation here ... }; // Explicitly pass type `int` as template argument. auto seq = std :: integer_sequence < int , 0 , 1 , 2 > (); // Type is deduced to be `int`. auto seq2 = my_integer_sequence < 0 , 1 , 2 > ();","title":"Declaring non-type template parameters with auto"},{"location":"coding/c%2B%2B/cpp_17/#folding-expressions","text":"A fold expression performs a fold of a template parameter pack over a binary operator. An expression of the form (... op e) or (e op ...) , where op is a fold-operator and e is an unexpanded parameter pack, are called unary folds. An expression of the form (e1 op ... op e2) , where op are fold-operators, is called a binary fold. Either e1 or e2 is an unexpanded parameter pack, but not both. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename ... Args > bool logicalAnd ( Args ... args ) { // Binary folding. return ( true && ... && args ); } bool b = true ; bool & b2 = b ; logicalAnd ( b , b2 , true ); // == true template < typename ... Args > auto sum ( Args ... args ) { // Unary folding. return (... + args ); } sum ( 1.0 , 2.0f , 3 ); // == 6.0","title":"Folding expressions"},{"location":"coding/c%2B%2B/cpp_17/#new-rules-for-auto-deduction-from-braced-init-list","text":"Changes to auto deduction when used with the uniform initialization syntax. Previously, auto x {3} deduced a std::initializer_list<int> , which now deduces to int . 1 2 3 4 auto x1 { 1 , 2 , 3 }; // error: not a single element. auto x2 = { 1 , 2 , 3 }; // x2 is std::initializer_list<int> auto x3 { 3 }; // x3 is int auto x4 { 3.0 }; // x4 is double","title":"New rules for auto deduction from braced-init-list"},{"location":"coding/c%2B%2B/cpp_17/#constexpr-lambda","text":"Compile-time lambda using constexpr . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto identity = []( int n ) constexpr { return n ; }; static_assert ( identity ( 123 ) == 123 ); constexpr auto add = []( int x , int y ) { auto L = [ = ] { return x ; }; auto R = [ = ] { return y ; }; return [ = ] { return L () + R (); }; }; static_assert ( add ( 1 , 2 )() == 3 ); constexpr int addOne ( int n ) { return [ n ] { return n + 1 ; }(); } static_assert ( addOne ( 1 ) == 2 );","title":"constexpr lambda"},{"location":"coding/c%2B%2B/cpp_17/#lambda-capture-this-by-value","text":"Capturing this in a lambda's environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. *this (C++17) will now make a copy of the current object, while this (C++11) continues to capture by reference. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct MyObj { int value { 123 }; auto getValueCopy () { return [ * this ] { return value ; }; } auto getValueRef () { return [ this ] { return value ; }; } }; MyObj mo ; auto valueCopy = mo . getValueCopy (); auto valueRef = mo . getValueRef (); mo . value = 321 ; valueCopy (); // 123 valueRef (); // 321","title":"Lambda capture this by value"},{"location":"coding/c%2B%2B/cpp_17/#inline-variables","text":"The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline. 1 2 3 4 5 6 7 8 // Disassembly example using compiler explorer. struct S { int x ; }; inline S x1 = S { 321 }; // mov esi, dword ptr [x1] // x1: .long 321 S x2 = S { 123 }; // mov eax, dword ptr [.L_ZZ4mainE2x2] // mov dword ptr [rbp - 8], eax // .L_ZZ4mainE2x2: .long 123 It can also be used to declare and define a static member variable, such that it does not need to be initialized in the source file. 1 2 3 4 5 6 struct S { S () : id { count ++ } {} ~ S () { count -- ; } int id ; static inline int count { 0 }; // declare and initialize count to 0 within the class };","title":"Inline variables"},{"location":"coding/c%2B%2B/cpp_17/#nested-namespaces","text":"Using the namespace resolution operator to create nested namespace definitions. 1 2 3 4 5 6 7 8 9 10 11 namespace A { namespace B { namespace C { int i ; } } } // vs. namespace A :: B :: C { int i ; }","title":"Nested namespaces"},{"location":"coding/c%2B%2B/cpp_17/#structured-bindings","text":"A proposal for de-structuring initialization, that would allow writting auto [ x, y, z] = expr; where the type of expr was a tuple-like object, whose elements would be bound to the variables x , y and z (which is construc declares). tuple-like objects include std::tuple , std::pair , std::array , and aggregate structures. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using Coordinate = std :: pair < int , int > ; Coordinate origin () { return Coordinate { 0 , 0 }; } const auto [ x , y ] = origin (); x ; // == 0 y ; // == 0 std :: unordered_map < std :: string , int > mapping { { \"a\" , 1 }, { \"b\" , 2 }, { \"c\" , 3 } }; // Destructure by reference. for ( const auto & [ key , value ] : mapping ) { // Do something with key and value }","title":"Structured bindings"},{"location":"coding/c%2B%2B/cpp_17/#selection-statements-with-initializer","text":"New version of if and switch statements which simplify code patterns and help users keep scopes tight. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { std :: lock_guard < std :: mutex > lk ( mx ); if ( v . empty ()) v . push_back ( val ); } // vs. if ( std :: lock_guard < std :: mutex > lk ( mx ); v . empty ()) { v . push_back ( val ); } Foo gadget ( args ); switch ( auto s = gadget . status ()) { case OK : gadget . zip (); break ; case Bad : throw BadFoo ( s . message ()); } // vs. switch ( Foo gadget ( args ); auto s = gadget . status ()) { case OK : gadget . zip (); break ; case Bad : throw BadFoo ( s . message ()); }","title":"Selection statements with initializer"},{"location":"coding/c%2B%2B/cpp_17/#constexpr-if","text":"Write code that is instantiated depending on a compile=time condition. 1 2 3 4 5 6 7 8 9 10 11 12 13 template < typename T > constexpr bool isIntegral () { if constexpr ( std :: is_integral < T >:: value ) { return true ; } else { return false ; } } static_assert ( isIntegral < int > () == true ); static_assert ( isIntegral < char > () == true ); static_assert ( isIntegral < double > () == false ); struct S {}; static_assert ( isIntegral < S > () == false );","title":"constexpr if"},{"location":"coding/c%2B%2B/cpp_17/#utf-8-character-literals","text":"A character literal that begins with u8 is a character literal of type char . The value of a UTF-8 character literal is equal to its ISO 10646 code point value. 1 char x = u8 'x' ;","title":"UTF-8 character literals"},{"location":"coding/c%2B%2B/cpp_17/#direct-list-initialization-of-enums","text":"Enums can now be initialized using braced syntax. 1 2 3 4 5 enum byte : unsigned char {}; byte b { 0 }; // OK byte c { -1 }; // ERROR byte d = byte { 1 }; // OK byte e = byte { 256 }; // ERROR","title":"Direct list initialization of enums"},{"location":"coding/c%2B%2B/cpp_17/#fallthrough-nodiscard-maybe_unused-attributes","text":"C++17 introduces threee new attributes: [[fallthrough]] : indicates to the compiler that falling through in a switch statement is intended behavior. 1 2 3 4 5 6 7 switch ( n ) { case 1 : [[ fallthrough ]] // ... case 2 : // ... break ; } [[nodiscard]] : issues a warning when either a function or class has this attribute and its return value is discarded. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [[ nodiscard ]] bool do_something () { return is_success ; // true for success, false for failure } do_something (); // warning: ignoring return value of 'bool do_something()', // declared with attribute 'nodiscard' // Only issues a warning when `error_info` is returned by value. struct [[ nodiscard ]] error_info { // ... }; error_info do_something () { error_info ei ; // ... return ei ; } do_something (); // warning: ignoring returned value of type 'error_info', // declared with attribute 'nodiscard' [[maybe_unused]] : indicates to be compiler that a variable or parameter might be unused an is intended. 1 2 3 4 void my_callback ( std :: string msg , [[ maybe_unused ]] bool error ) { // Don't care if `msg` is an error message, just log it. log ( msg ); }","title":"fallthrough, nodiscard, maybe_unused attributes"},{"location":"coding/c%2B%2B/cpp_17/#c17-new-libraries","text":"","title":"C++17 New Libraries"},{"location":"coding/c%2B%2B/cpp_17/#stdvariant","text":"The class template std::variant represents a type-safe union . An instance of std::variant at any given time holds a value of one of its alternativqe types(it's possible for it to be valueless). 1 2 3 4 5 6 std :: variant < int , double > v { 12 }; std :: get < int > ( v ); // == 12 std :: get < 0 > ( v ); // == 12 v = 12.0 ; std :: get < double > ( v ); // == 12.0 std :: get < 1 > ( v ); // == 12.0","title":"std::variant"},{"location":"coding/c%2B%2B/cpp_17/#stdoptional","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 std :: optional < std :: string > create ( bool b ) { if ( b ) { return \"Godzilla\" ; } else { return {}; } } create ( false ). value_or ( \"empty\" ); // == \"empty\" create ( true ). value (); // == \"Godzilla\" // optional-returning factory functions are usable as conditions of while and if if ( auto str = create ( true )) { // ... }","title":"std::optional"},{"location":"coding/c%2B%2B/cpp_17/#stdany","text":"A type-safe container for single values of any type. 1 2 3 4 5 std :: any x { 5 }; x . has_value () // == true std :: any_cast < int > ( x ) // == 5 std :: any_cast < int &> ( x ) = 10 ; std :: any_cast < int > ( x ) // == 10","title":"std::any"},{"location":"coding/c%2B%2B/cpp_17/#stdstring_view","text":"A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing). 1 2 3 4 5 6 7 8 9 10 11 12 13 // Regular strings. std :: string_view cppstr { \"foo\" }; // Wide strings. std :: wstring_view wcstr_v { L \"baz\" }; // Character arrays. char array [ 3 ] = { 'b' , 'a' , 'r' }; std :: string_view array_v ( array , std :: size ( array )); std :: string str { \" trim me\" }; std :: string_view v { str }; v . remove_prefix ( std :: min ( v . find_first_not_of ( \" \" ), v . size ())); str ; // == \" trim me\" v ; // == \"trim me\"","title":"std::string_view"},{"location":"coding/c%2B%2B/cpp_17/#stdinvoke","text":"Invoke a Callable object with parameters. Examples of Callable objects are std::function or std::bind where an object can be called similarly to a regular function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template < typename Callable > class Proxy { Callable c ; public : Proxy ( Callable c ) : c ( c ) {} template < class ... Args > decltype ( auto ) operator ()( Args && ... args ) { // ... return std :: invoke ( c , std :: forward < Args > ( args )...); } }; auto add = []( int x , int y ) { return x + y ; }; Proxy < decltype ( add ) > p { add }; p ( 1 , 2 ); // == 3","title":"std::invoke"},{"location":"coding/c%2B%2B/cpp_17/#stdapply","text":"Invoke a Callable object with a tuple of arguments 1 2 3 4 auto add = []( int x , int y ) { return x + y ; }; std :: apply ( add , std :: make_tuple ( 1 , 2 )); // == 3","title":"std::apply"},{"location":"coding/c%2B%2B/cpp_17/#stdfilesystem","text":"The new std::filesystem library provides a standard way to manipulate files, directories, and paths in a filesystem. 1 2 3 4 5 6 7 8 9 const auto bigFilePath { \"bigFileToCopy\" }; if ( std :: filesystem :: exists ( bigFilePath )) { const auto bigFileSize { std :: filesystem :: file_size ( bigFilePath )}; std :: filesystem :: path tmpPath { \"/tmp\" }; if ( std :: filesystem :: space ( tmpPath ). available > bigFileSize ) { std :: filesystem :: create_directory ( tmpPath . append ( \"example\" )); std :: filesystem :: copy_file ( bigFilePath , tmpPath . append ( \"newFile\" )); } }","title":"std::filesystem"},{"location":"coding/c%2B%2B/cpp_17/#stdbyte","text":"The new std::byte type provides a standard way of representing data as byte. Benefits of using std::byte over char or unsigned char is that it is not a character type, and is also not an arithmetic type; while the only operator overloads available are bitwise operator. 1 2 3 4 5 std :: byte a { 0 }; std :: byte b { 0xFF }; int i = std :: to_integer < int > ( b ); // 0xFF std :: byte c = a & b ; int j = std :: to_integer < int > ( c ); // 0","title":"std::byte"},{"location":"coding/c%2B%2B/cpp_17/#splicing-for-maps-and-sets","text":"Moving nodes and merging containers whithout the overhead of expensive copies, moves, or heap allocations/deallocations. Moving elements from one map to another: 1 2 3 4 5 std :: map < int , string > src {{ 1 , \"one\" }, { 2 , \"two\" }, { 3 , \"buckle my shoe\" }}; std :: map < int , string > dst {{ 3 , \"three\" }}; dst . insert ( src . extract ( src . find ( 1 ))); // Cheap remove and insert of { 1, \"one\" } from `src` to `dst`. dst . insert ( src . extract ( 2 )); // Cheap remove and insert of { 2, \"two\" } from `src` to `dst`. // dst == { { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } }; Inserting elements which outlive the container: 1 2 3 4 5 6 auto elementFactory () { std :: set < ... > s ; s . emplace (...); return s . extract ( s . begin ()); } s2 . insert ( elementFactory ()); Changing the key of a map element: 1 2 3 4 5 std :: map < int , string > m {{ 1 , \"one\" }, { 2 , \"two\" }, { 3 , \"three\" }}; auto e = m . extract ( 2 ); e . key () = 4 ; m . insert ( std :: move ( e )); // m == { { 1, \"one\" }, { 3, \"three\" }, { 4, \"two\" } }","title":"Splicing for maps and sets"},{"location":"coding/c%2B%2B/cpp_17/#parallel-algorithms","text":"Many of the STL algorithms, such as the copy , find and sort methods, started to support the parallel execution policies: seq , par and par_unseq which translate to \"sequentially\", \"parallel\" and \"parallel unsequenced\". 1 2 3 4 5 std :: vector < int > longVector ; // Find element using parallel execution policy auto result1 = std :: find ( std :: execution :: par , std :: begin ( longVector ), std :: end ( longVector ), 2 ); // Sort elements using sequential execution policy auto result2 = std :: sort ( std :: execution :: seq , std :: begin ( longVector ), std :: end ( longVector ));","title":"parallel algorithms"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/","text":"This page is the note of Bjarne's speech at Edinburgh from youtobe. What did/do I want? \u00b6 Type safety - Encapsulate necessary unsafe operations Resource safety - it's not all memory Performance - For some parts of almost all systems,it's important Predictability - For hard and soft real time Teachability - Complexity of code should be proportional to the complexity of the task Readability - People and machines(\"analyzability\") Who did/do I want it for? \u00b6 Primary concerns - Systems propramming - Embedded systems - Resource constrained systems - Large systems Experts - \"c++ is expert friendly\" Novices - \"c++ is not just expert friendly\" C++ in two lines \u00b6 What is C++? \u00b6 Direct map to hardware - of instructions and dundamental data types - Initially from C Zero-Overhead abstraction - Classes with constructors and destructors,inheritance,generic programming,functional programming techniques - Initially from Simula Much of the inspiration came from operating systems What does C++ wants to be when it grows up? - See above - And better at it for more modern hardware and techniques - Compatibility/stability is a feature Cpp is a light-weight abstraction programming language \u00b6 building and using efficient and elegant abstractions Key strengths: \u00b6 software infrastructure resource-constrained applications Resource Management \u00b6 A resource is something that must be acquired and latter released \u00b6 Explicitly or implicitly Resource management should not be manual we don't want leaks(\u6cc4\u9732) A resource should have an owner \u00b6 Usually a \"handle\" A \"handle\" should present a well-defined and useful abstraction All the standard-library containers manage their elements \u00b6 vector list,forward_list(singly-linked list),... map,unordered_map(hash table),... set,multi_set,... string Other standard-library classes manage other resoures \u00b6 Not just memory(Garbage collection is not sufficient) thread,lock_guard,... istream,fstream,... unique_ptr,shared_ptr,... Use constructors and destructor \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename T > class Vector { public : Vector ( initializer_list < T > ); //vector of elements of type T ~ Vector (); //... private : T * elem ; //pointer to elements int sz ; //number of elements }; void fct (){ Vector < double > vd { 1 , 1.625 , 3.14 , 2.998e8 }; Vector < string > vs { \"Strachey\" , \"Richards\" }; } Pointer Misuse \u00b6 Many(most) uses of pointers in local scope are not exception safe 1 2 3 4 5 6 7 8 void f ( int n , int x ){ Gadget * p = new Gadget ( n ); //... if ( x < 100 ) throw std :: runtime_error ( \"Weird!\" ); //leak if ( x < 200 ) return ; //leak //... delete p ; //I want my garbage collector! } 1 2 But garbage collection would not release non-memory resources Why use a \"naked\" pointer? Resource Handles and Pointers \u00b6 A std::shared_ptr releases its object at when the last shared_ptr to it is destroyed 1 2 3 4 5 6 7 void f ( int n , int x ){ auto p = make_shared < Gadget > ( n ); //manage that pointer! //... if ( x < 100 ) throw std :: runtime_error ( \"Weird!\" ); //no leak if ( x < 200 ) return ; //no leak //... } shared_ptr provides a form of garbage collection(But I'm not sharing anything!) A std::unique_ptr releases its object at when it goes out of scope 1 2 3 4 5 6 7 void f ( int n , int x ){ auto p = make_unique < Gadget > ( n ); //manage that pointer! //... if ( x < 100 ) throw std :: runtime_error ( \"Weird!\" ); //no leak if ( x < 200 ) return ; //no leak //... } This is simple and cheap No more expensive than a \"plain old pointer\" Error Handling and Resources \u00b6 \"Resource Acquistion Is Intialization\"(RAII) 1. Acquire during construction 2. Release in destructor Throw exception in case of failure In particular, throw is a constructor cannot construct and object Never throw while holding a resource not owned by a handle Never leak In general Leave established invariants intact when leaving a scope Why do we use pointers? \u00b6 And references,iterators,etc. To represent ownership Don't Stop! Instead, use handles To reference resources from within a handle To represent positions Be careful To pass large amounts of data(into a function) E.g. pass by const reference To return large amount of data(out of a function) Don't! Instead use move operations How to get a lot of data cheaply out of a function? \u00b6 Consider factory functions functions returning lots of objects Return a pointer to a new 'd object? M* operator+(const M&, const M&); M* pm = m1 + m2; //ugly: and who does the delete? M q = pm + m3; //ugly: and who does the delete? Return a reference to a new 'd object? M& operator+(const M&, const M&); M m = m1 + m2; //looks OK; but who does the delete? delete what? Pass a target object? void operator+(const M&, const M&, M& result); M m; operator+(m1, m2, m); //ugly: We are regressing(\u9000\u5316,\u56de\u5f52) towards assembly code(\u6c47\u7f16\u4ee3\u7801) conslusion - Consider factory functions functions returning lots of objects(in containers) - Return an object! M operator+(const M&, const M&); How? Becase copies are expensive Tricks to avoid copying are brittle Tricks to avoid copying are not general - Return a handle sample and cheap Move semantics \u00b6 Direct support in C++11:Move constructor 1 2 3 4 5 6 7 8 9 10 class Matrix { Representation rep ; //... Matrix ( Matrix && a ) //move constructor { rep = a . rep ; //*this gets a's elements a . rep = {}; //a becomes the empty Matrix } }; Matrix res = a + b ; Often, you can avoid writing copy and move operations Easily avoid 1 2 3 4 class Matrix { vector < double > elem ; //elements here //...matrix access... }; Matrix just \"inherit\" resource management from vector Copy and a move operations can often be implicitly generated from members Good copy and move operations, e.g from the standard library","title":"Bjarne Strooustrup:The Essence of C++"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#what-diddo-i-want","text":"Type safety - Encapsulate necessary unsafe operations Resource safety - it's not all memory Performance - For some parts of almost all systems,it's important Predictability - For hard and soft real time Teachability - Complexity of code should be proportional to the complexity of the task Readability - People and machines(\"analyzability\")","title":"What did/do I want?"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#who-diddo-i-want-it-for","text":"Primary concerns - Systems propramming - Embedded systems - Resource constrained systems - Large systems Experts - \"c++ is expert friendly\" Novices - \"c++ is not just expert friendly\"","title":"Who did/do I want it for?"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#c-in-two-lines","text":"","title":"C++ in two lines"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#what-is-c","text":"Direct map to hardware - of instructions and dundamental data types - Initially from C Zero-Overhead abstraction - Classes with constructors and destructors,inheritance,generic programming,functional programming techniques - Initially from Simula Much of the inspiration came from operating systems What does C++ wants to be when it grows up? - See above - And better at it for more modern hardware and techniques - Compatibility/stability is a feature","title":"What is C++?"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#cpp-is-a-light-weight-abstraction-programming-language","text":"building and using efficient and elegant abstractions","title":"Cpp is a light-weight abstraction programming language"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#key-strengths","text":"software infrastructure resource-constrained applications","title":"Key strengths:"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#resource-management","text":"","title":"Resource Management"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#a-resource-is-something-that-must-be-acquired-and-latter-released","text":"Explicitly or implicitly Resource management should not be manual we don't want leaks(\u6cc4\u9732)","title":"A resource is something that must be acquired and latter released"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#a-resource-should-have-an-owner","text":"Usually a \"handle\" A \"handle\" should present a well-defined and useful abstraction","title":"A resource should have an owner"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#all-the-standard-library-containers-manage-their-elements","text":"vector list,forward_list(singly-linked list),... map,unordered_map(hash table),... set,multi_set,... string","title":"All the standard-library containers manage their elements"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#other-standard-library-classes-manage-other-resoures","text":"Not just memory(Garbage collection is not sufficient) thread,lock_guard,... istream,fstream,... unique_ptr,shared_ptr,...","title":"Other standard-library classes manage other resoures"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#use-constructors-and-destructor","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename T > class Vector { public : Vector ( initializer_list < T > ); //vector of elements of type T ~ Vector (); //... private : T * elem ; //pointer to elements int sz ; //number of elements }; void fct (){ Vector < double > vd { 1 , 1.625 , 3.14 , 2.998e8 }; Vector < string > vs { \"Strachey\" , \"Richards\" }; }","title":"Use constructors and destructor"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#pointer-misuse","text":"Many(most) uses of pointers in local scope are not exception safe 1 2 3 4 5 6 7 8 void f ( int n , int x ){ Gadget * p = new Gadget ( n ); //... if ( x < 100 ) throw std :: runtime_error ( \"Weird!\" ); //leak if ( x < 200 ) return ; //leak //... delete p ; //I want my garbage collector! } 1 2 But garbage collection would not release non-memory resources Why use a \"naked\" pointer?","title":"Pointer Misuse"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#resource-handles-and-pointers","text":"A std::shared_ptr releases its object at when the last shared_ptr to it is destroyed 1 2 3 4 5 6 7 void f ( int n , int x ){ auto p = make_shared < Gadget > ( n ); //manage that pointer! //... if ( x < 100 ) throw std :: runtime_error ( \"Weird!\" ); //no leak if ( x < 200 ) return ; //no leak //... } shared_ptr provides a form of garbage collection(But I'm not sharing anything!) A std::unique_ptr releases its object at when it goes out of scope 1 2 3 4 5 6 7 void f ( int n , int x ){ auto p = make_unique < Gadget > ( n ); //manage that pointer! //... if ( x < 100 ) throw std :: runtime_error ( \"Weird!\" ); //no leak if ( x < 200 ) return ; //no leak //... } This is simple and cheap No more expensive than a \"plain old pointer\"","title":"Resource Handles and Pointers"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#error-handling-and-resources","text":"\"Resource Acquistion Is Intialization\"(RAII) 1. Acquire during construction 2. Release in destructor Throw exception in case of failure In particular, throw is a constructor cannot construct and object Never throw while holding a resource not owned by a handle Never leak In general Leave established invariants intact when leaving a scope","title":"Error Handling and Resources"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#why-do-we-use-pointers","text":"And references,iterators,etc. To represent ownership Don't Stop! Instead, use handles To reference resources from within a handle To represent positions Be careful To pass large amounts of data(into a function) E.g. pass by const reference To return large amount of data(out of a function) Don't! Instead use move operations","title":"Why do we use pointers?"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#how-to-get-a-lot-of-data-cheaply-out-of-a-function","text":"Consider factory functions functions returning lots of objects Return a pointer to a new 'd object? M* operator+(const M&, const M&); M* pm = m1 + m2; //ugly: and who does the delete? M q = pm + m3; //ugly: and who does the delete? Return a reference to a new 'd object? M& operator+(const M&, const M&); M m = m1 + m2; //looks OK; but who does the delete? delete what? Pass a target object? void operator+(const M&, const M&, M& result); M m; operator+(m1, m2, m); //ugly: We are regressing(\u9000\u5316,\u56de\u5f52) towards assembly code(\u6c47\u7f16\u4ee3\u7801) conslusion - Consider factory functions functions returning lots of objects(in containers) - Return an object! M operator+(const M&, const M&); How? Becase copies are expensive Tricks to avoid copying are brittle Tricks to avoid copying are not general - Return a handle sample and cheap","title":"How to get a lot of data cheaply out of a function?"},{"location":"coding/c%2B%2B/the_essence_of_c%2B%2B/#move-semantics","text":"Direct support in C++11:Move constructor 1 2 3 4 5 6 7 8 9 10 class Matrix { Representation rep ; //... Matrix ( Matrix && a ) //move constructor { rep = a . rep ; //*this gets a's elements a . rep = {}; //a becomes the empty Matrix } }; Matrix res = a + b ; Often, you can avoid writing copy and move operations Easily avoid 1 2 3 4 class Matrix { vector < double > elem ; //elements here //...matrix access... }; Matrix just \"inherit\" resource management from vector Copy and a move operations can often be implicitly generated from members Good copy and move operations, e.g from the standard library","title":"Move semantics"},{"location":"coding/system%26structure/operation_system/","text":"\u7a0b\u5e8f\u6d41\u7a0b \u00b6 \u9884\u7f16\u8bd1->\u7f16\u8bd1\u548c\u4f18\u5316->\u6c47\u7f16->\u94fe\u63a5 - \u9884\u7f16\u8bd1:\u5f15\u7528\u7684\u5934\u6587\u4ef6\u5305\u542b\u5230\u6e90\u4ee3\u7801 - static and shared libs - static:\u66f4\u5feb\u3001\u66f4\u6613\u7528\u3001\u66f4\u5927 - shared:\u9700\u8981\u5b89\u88c5\u3001\u5c0f\u3001\u76f8\u6bd4static\u6162\u3001\u7cfb\u7edf\u4e2d\u914d\u7f6e\u6587\u4ef6 /etc/ld.so.conf \u662f\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u641c\u7d22\u8def\u5f84\u914d\u7f6e\u6587\u4ef6 - ldconfig -p","title":"Operation system"},{"location":"coding/system%26structure/operation_system/#_1","text":"\u9884\u7f16\u8bd1->\u7f16\u8bd1\u548c\u4f18\u5316->\u6c47\u7f16->\u94fe\u63a5 - \u9884\u7f16\u8bd1:\u5f15\u7528\u7684\u5934\u6587\u4ef6\u5305\u542b\u5230\u6e90\u4ee3\u7801 - static and shared libs - static:\u66f4\u5feb\u3001\u66f4\u6613\u7528\u3001\u66f4\u5927 - shared:\u9700\u8981\u5b89\u88c5\u3001\u5c0f\u3001\u76f8\u6bd4static\u6162\u3001\u7cfb\u7edf\u4e2d\u914d\u7f6e\u6587\u4ef6 /etc/ld.so.conf \u662f\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u641c\u7d22\u8def\u5f84\u914d\u7f6e\u6587\u4ef6 - ldconfig -p","title":"\u7a0b\u5e8f\u6d41\u7a0b"},{"location":"coding/system%26structure/several_design_patterns_by_cpp/","text":"Introduce some normal design patterns,codes by cpp. Strategy Pattern \u00b6 Intent \u00b6 Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from the clients that use it. Capture the abstraction in an interface, bury implementation details in derived classes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 //By dexter @ 11/10/2020 #include <iostream> class Strategy { public : explicit Strategy (){} virtual ~ Strategy (){} virtual void exec () = 0 ; private : Strategy ( const Strategy & rhs ); Strategy & operator = ( const Strategy & rhs ); }; class ConcreteStrategyA : public Strategy { public : explicit ConcreteStrategyA () : Strategy () {} ~ ConcreteStrategyA () {} void exec (){ std :: cout << \"ConcreteStrategyA::exec()\" << std :: endl ; } private : ConcreteStrategyA ( const ConcreteStrategyA & rhs ); ConcreteStrategyA & operator = ( const ConcreteStrategyA & rhs ); }; class ConcreteStrategyB : public Strategy { public : explicit ConcreteStrategyB () : Strategy () {} ~ ConcreteStrategyB (){} void exec () { std :: cout << \"ConcreteStrategyB::exec()\" << std :: endl ; } private : ConcreteStrategyB ( const ConcreteStrategyB & rhs ); ConcreteStrategyB & operator = ( const ConcreteStrategyB & rhs ); }; class Context { public : explicit Context ( Strategy * strategy ) : strategy_ ( strategy ){} ~ Context (){} void setSetrategy ( Strategy * strategy ) { strategy_ = strategy ; } void exec () { strategy_ -> exec (); } private : Context ( const Context & rhs ); Context & operator = ( const Context & rhs ); Strategy * strategy_ ; }; int main () { ConcreteStrategyA stra_a ; ConcreteStrategyB stra_b ; std :: cerr << \"set a strategy: \\n \" ; Context cont ( & stra_a ); cont . exec (); std :: cerr << \"set a strategy: \\n \" ; cont . setSetrategy ( & stra_b ); cont . exec (); return 0 ; } output: 1 2 3 4 set a strategy: ConcreteStrategyA::exec () set a strategy: ConcreteStrategyB::exec () Observer Pattern \u00b6 Observer pattern is used when there is one-to-many relationship between objects such as if one object is modified, its dependent objects are to be notified automatically. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 //By dexter @ 12/10/2020 #include <iostream> #include <vector> class Observer { public : explicit Observer () {} virtual ~ Observer () {} virtual void update () = 0 ; private : Observer ( const Observer & rhs ); Observer & operator = ( const Observer & rhs ); }; class ConcreteObserveA : public Observer { public : explicit ConcreteObserveA () : Observer () {} ~ ConcreteObserveA () {} void update () { std :: cerr << \"ConcreteObserveA::update \\n \" ; } private : ConcreteObserveA ( const ConcreteObserveA & rhs ); ConcreteObserveA & operator = ( const ConcreteObserveA & rhs ); }; class ConcreteObserveB : public Observer { public : explicit ConcreteObserveB () : Observer () {} ~ ConcreteObserveB () {} void update () { std :: cerr << \"ConcreteObserveB::update \\n \" ; } private : ConcreteObserveB ( const ConcreteObserveB & rhs ); ConcreteObserveB & operator = ( const ConcreteObserveB & rhs ); }; class Subject { public : explicit Subject () {} virtual ~ Subject () {} virtual void registerObserver ( Observer * observer ) = 0 ; virtual void removeObserver ( Observer * observer ) = 0 ; virtual void notifyObserver () = 0 ; private : Subject ( const Subject & rhs ); Subject & operator = ( const Subject & rhs ); }; class ConcreteSubjectA : public Subject { public : explicit ConcreteSubjectA () : Subject () {} ~ ConcreteSubjectA () {} void registerObserver ( Observer * observer ) { observer_list_ . push_back ( observer ); } void removeObserver ( Observer * observer ) { for ( auto it = observer_list_ . begin (); it != observer_list_ . end (); it ++ ){ if ( * it == observer ){ observer_list_ . erase ( it ); return ; } } } void notifyObserver () { for ( auto it = observer_list_ . begin (); it != observer_list_ . end (); it ++ ){ ( * it ) -> update (); } } private : ConcreteSubjectA ( const ConcreteSubjectA & rhs ); ConcreteSubjectA & operator = ( const ConcreteSubjectA & rhs ); std :: vector < Observer *> observer_list_ ; }; int main () { ConcreteObserveA obser_a ; ConcreteObserveB obser_b ; ConcreteSubjectA suba ; std :: cerr << \"add two observer and update: \\n \" ; suba . registerObserver ( & obser_a ); suba . registerObserver ( & obser_b ); suba . notifyObserver (); std :: cout << \"remove obser_a and update: \\n \" ; suba . removeObserver ( & obser_a ); suba . notifyObserver (); return 0 ; } output: 1 2 3 4 5 add two observer and update: ConcreteObserveA::update ConcreteObserveB::update remove obser_a and update: ConcreteObserveB::update Decorator Pattern \u00b6 Decorator pattern allows a user to add new functionality to an existing object without altering its structure. This type of design pattern comes under structural pattern as this pattern acts as a wrapper to existing class. This pattern creates a decorator class which wraps the original class and privides additional functionality keeping class methods signature inact; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 //By dexter @ 12/10/2020 #include <iostream> #include <string> #include <memory> class Component { public : explicit Component () {} Component ( const Component & rhs ) = delete ; Component & operator = ( const Component & rhs ) = delete ; virtual ~ Component () {} virtual std :: string methodA () = 0 ; virtual std :: string methodB () = 0 ; private : }; class ConcreteComponentA : public Component { public : ConcreteComponentA () : Component () {} ~ ConcreteComponentA () {} ConcreteComponentA ( const ConcreteComponentA & rhs ) = delete ; ConcreteComponentA & operator = ( const ConcreteComponentA & rhs ) = delete ; std :: string methodA (){ return \"ConcreteComponentA methodA\" ; } std :: string methodB (){ return \"ConcreteComponentA methodB\" ; } private : }; class Decorator : public Component { public : Decorator ( std :: shared_ptr < Component > component ) : component_ ( component ) {} ~ Decorator () {} Decorator ( const Decorator & rhs ) = delete ; Decorator & operator = ( const Decorator & rhs ) = delete ; std :: string methodA () { return component_ -> methodA (); } std :: string methodB () { return component_ -> methodB (); } private : protected : std :: shared_ptr < Component > component_ ; }; class ConcreteDecoratorA : public Decorator { public : ConcreteDecoratorA ( std :: shared_ptr < Component > component ) : Decorator ( component ) {} ~ ConcreteDecoratorA () {} ConcreteDecoratorA ( const ConcreteDecoratorA & rhs ) = delete ; ConcreteDecoratorA & operator = ( const ConcreteDecoratorA & rhs ) = delete ; std :: string methodA (){ return component_ -> methodA () + \" ConcreteDecoratorA methodA\" ; } std :: string methodB (){ return component_ -> methodB () + \" ConcreteDecoratorA methodB\" ; } private : }; class ConcreteDecoratorB : public Decorator { public : ConcreteDecoratorB ( std :: shared_ptr < Component > component ) : Decorator ( component ) {} ~ ConcreteDecoratorB () {} ConcreteDecoratorB ( const ConcreteDecoratorB & rhs ) = delete ; ConcreteDecoratorB & operator = ( const ConcreteDecoratorB & rhs ) = delete ; std :: string methodA (){ return component_ -> methodA () + \" ConcreteDecoratorB methodA\" ; } std :: string methodB (){ return component_ -> methodB () + \" ConcreteDecoratorB methodB\" ; } private : }; int main () { std :: shared_ptr < ConcreteComponentA > ptr_component_a = std :: make_shared < ConcreteComponentA > (); std :: cout << ptr_component_a -> methodA () << \", \" << ptr_component_a -> methodB () << std :: endl ; std :: shared_ptr < ConcreteDecoratorA > ptr_decorator_a = std :: make_shared < ConcreteDecoratorA > ( ptr_component_a ); std :: cout << ptr_decorator_a -> methodA () << \", \" << ptr_decorator_a -> methodB () << std :: endl ; std :: shared_ptr < ConcreteDecoratorB > ptr_decorator_b = std :: make_shared < ConcreteDecoratorB > ( ptr_component_a ); std :: cout << ptr_decorator_b -> methodA () << \", \" << ptr_decorator_b -> methodB () << std :: endl ; std :: shared_ptr < ConcreteDecoratorB > ptr_decorator_a_b = std :: make_shared < ConcreteDecoratorB > ( ptr_decorator_a ); std :: cout << ptr_decorator_a_b -> methodA () << \", \" << ptr_decorator_a_b -> methodB () << std :: endl ; return 0 ; } output: 1 2 3 4 ConcreteComponentA methodA, ConcreteComponentA methodB ConcreteComponentA methodA ConcreteDecoratorA methodA, ConcreteComponentA methodB ConcreteDecoratorA methodB ConcreteComponentA methodA ConcreteDecoratorB methodA, ConcreteComponentA methodB ConcreteDecoratorB methodB ConcreteComponentA methodA ConcreteDecoratorA methodA ConcreteDecoratorB methodA, ConcreteComponentA methodB ConcreteDecoratorA methodB ConcreteDecoratorB methodB Factory Pattern \u00b6 The factory pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact calss of the object that will be created. This is done by creating objects by calling a factory method, either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes rather than by calling a constructor. According to the type of problems, there are three kinds of Factory Pattern : - Simple Factory - Normal Factory - Abstract Factory Simple Factory \u00b6 Simple Factory defines a method to create an object. It voilates the Open/close Principle(OCP) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 //By dexter @ 13/10/2020 #include <iostream> #include <string> #include <memory> class Product { public : explicit Product () {} virtual ~ Product () {} Product ( const Product & rhs ) = delete ; Product & operator = ( const Product & rhs ) = delete ; virtual void operation () = 0 ; }; class ConcreteProductA : public Product { public : explicit ConcreteProductA () : Product () {} ~ ConcreteProductA () {} ConcreteProductA ( const ConcreteProductA & rhs ) = delete ; ConcreteProductA & operator = ( const ConcreteProductA & rhs ) = delete ; void operation () { std :: cerr << \"ConcreteProductA is called...\" << std :: endl ; } }; class ConcreteProductB : public Product { public : explicit ConcreteProductB () : Product () {} ~ ConcreteProductB () {} ConcreteProductB ( const ConcreteProductB & rhs ) = delete ; ConcreteProductB & operator = ( const ConcreteProductB & rhs ) = delete ; void operation () { std :: cerr << \"ConcreteProductB is called...\" << std :: endl ; } }; class Factory { public : Factory () {} ~ Factory () {} Factory ( const Factory & rhs ) = delete ; Factory & operator = ( const Factory & rhs ) = delete ; std :: shared_ptr < Product > createProduct ( const std :: string & product ) { if ( product == \"A\" ) { return std :: make_shared < ConcreteProductA > (); } if ( product == \"B\" ) { return std :: make_shared < ConcreteProductB > (); } } }; int main () { Factory factory ; std :: shared_ptr < Product > product_a = factory . createProduct ( \"A\" ); std :: shared_ptr < Product > product_b = factory . createProduct ( \"B\" ); product_a -> operation (); product_b -> operation (); return 0 ; } output: 1 2 ConcreteProductA is called... ConcreteProductB is called... Normal Factory \u00b6 Normal Factory not only encapsulates the creation of object but also put the creation of object into derived class. It only provides the method of creating objects, and the realization is in ConcreteFactory . Disadvantage: the addition of factory object will cause the increasing of classes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 //By dexter @ 13/10/2020 #include <iostream> #include <string> #include <memory> class Product { public : explicit Product () {} virtual ~ Product () {} Product ( const Product & rhs ) = delete ; Product & operator = ( const Product & rhs ) = delete ; virtual void operation () = 0 ; }; class ConcreteProductA : public Product { public : explicit ConcreteProductA () : Product () {} ~ ConcreteProductA () {} ConcreteProductA ( const ConcreteProductA & rhs ) = delete ; ConcreteProductA & operator = ( const ConcreteProductA & rhs ) = delete ; void operation () { std :: cerr << \"ConcreteProductA is called...\" << std :: endl ; } }; class ConcreteProductB : public Product { public : explicit ConcreteProductB () : Product (){} ~ ConcreteProductB () {} ConcreteProductB ( const ConcreteProductB & rhs ) = delete ; ConcreteProductB & operator = ( const ConcreteProductB & rhs ) = delete ; void operation () { std :: cerr << \"ConcreteProductB is called...\" << std :: endl ; } }; class Factory { public : explicit Factory () {} virtual ~ Factory () {} Factory ( const Factory & rhs ) = delete ; Factory & operator = ( const Factory & rhs ) = delete ; virtual std :: shared_ptr < Product > createProduct () = 0 ; }; class ConcreteFactoryA : public Factory { public : explicit ConcreteFactoryA () : Factory () {} ~ ConcreteFactoryA () {} ConcreteFactoryA ( const ConcreteFactoryA & rhs ) = delete ; ConcreteFactoryA & operator = ( const ConcreteFactoryA & rhs ) = delete ; std :: shared_ptr < Product > createProduct () { return std :: make_shared < ConcreteProductA > (); } }; class ConcreteFactoryB : public Factory { public : explicit ConcreteFactoryB () : Factory () {} ~ ConcreteFactoryB () {} ConcreteFactoryB ( const ConcreteFactoryB & rhs ) = delete ; ConcreteFactoryB & operator = ( const ConcreteFactoryB & rhs ) = delete ; std :: shared_ptr < Product > createProduct () { return std :: make_shared < ConcreteProductB > (); } }; int main () { auto factor_a = std :: make_shared < ConcreteFactoryA > (); auto product_a = factor_a -> createProduct (); product_a -> operation (); auto factor_b = std :: make_shared < ConcreteFactoryB > (); auto product_b = factor_b -> createProduct (); product_b -> operation (); return 0 ; } output: 1 2 ConcreteProductA is called... ConcreteProductB is called...","title":"Several Design Patterns By C++"},{"location":"coding/system%26structure/several_design_patterns_by_cpp/#strategy-pattern","text":"","title":"Strategy Pattern"},{"location":"coding/system%26structure/several_design_patterns_by_cpp/#intent","text":"Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from the clients that use it. Capture the abstraction in an interface, bury implementation details in derived classes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 //By dexter @ 11/10/2020 #include <iostream> class Strategy { public : explicit Strategy (){} virtual ~ Strategy (){} virtual void exec () = 0 ; private : Strategy ( const Strategy & rhs ); Strategy & operator = ( const Strategy & rhs ); }; class ConcreteStrategyA : public Strategy { public : explicit ConcreteStrategyA () : Strategy () {} ~ ConcreteStrategyA () {} void exec (){ std :: cout << \"ConcreteStrategyA::exec()\" << std :: endl ; } private : ConcreteStrategyA ( const ConcreteStrategyA & rhs ); ConcreteStrategyA & operator = ( const ConcreteStrategyA & rhs ); }; class ConcreteStrategyB : public Strategy { public : explicit ConcreteStrategyB () : Strategy () {} ~ ConcreteStrategyB (){} void exec () { std :: cout << \"ConcreteStrategyB::exec()\" << std :: endl ; } private : ConcreteStrategyB ( const ConcreteStrategyB & rhs ); ConcreteStrategyB & operator = ( const ConcreteStrategyB & rhs ); }; class Context { public : explicit Context ( Strategy * strategy ) : strategy_ ( strategy ){} ~ Context (){} void setSetrategy ( Strategy * strategy ) { strategy_ = strategy ; } void exec () { strategy_ -> exec (); } private : Context ( const Context & rhs ); Context & operator = ( const Context & rhs ); Strategy * strategy_ ; }; int main () { ConcreteStrategyA stra_a ; ConcreteStrategyB stra_b ; std :: cerr << \"set a strategy: \\n \" ; Context cont ( & stra_a ); cont . exec (); std :: cerr << \"set a strategy: \\n \" ; cont . setSetrategy ( & stra_b ); cont . exec (); return 0 ; } output: 1 2 3 4 set a strategy: ConcreteStrategyA::exec () set a strategy: ConcreteStrategyB::exec ()","title":"Intent"},{"location":"coding/system%26structure/several_design_patterns_by_cpp/#observer-pattern","text":"Observer pattern is used when there is one-to-many relationship between objects such as if one object is modified, its dependent objects are to be notified automatically. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 //By dexter @ 12/10/2020 #include <iostream> #include <vector> class Observer { public : explicit Observer () {} virtual ~ Observer () {} virtual void update () = 0 ; private : Observer ( const Observer & rhs ); Observer & operator = ( const Observer & rhs ); }; class ConcreteObserveA : public Observer { public : explicit ConcreteObserveA () : Observer () {} ~ ConcreteObserveA () {} void update () { std :: cerr << \"ConcreteObserveA::update \\n \" ; } private : ConcreteObserveA ( const ConcreteObserveA & rhs ); ConcreteObserveA & operator = ( const ConcreteObserveA & rhs ); }; class ConcreteObserveB : public Observer { public : explicit ConcreteObserveB () : Observer () {} ~ ConcreteObserveB () {} void update () { std :: cerr << \"ConcreteObserveB::update \\n \" ; } private : ConcreteObserveB ( const ConcreteObserveB & rhs ); ConcreteObserveB & operator = ( const ConcreteObserveB & rhs ); }; class Subject { public : explicit Subject () {} virtual ~ Subject () {} virtual void registerObserver ( Observer * observer ) = 0 ; virtual void removeObserver ( Observer * observer ) = 0 ; virtual void notifyObserver () = 0 ; private : Subject ( const Subject & rhs ); Subject & operator = ( const Subject & rhs ); }; class ConcreteSubjectA : public Subject { public : explicit ConcreteSubjectA () : Subject () {} ~ ConcreteSubjectA () {} void registerObserver ( Observer * observer ) { observer_list_ . push_back ( observer ); } void removeObserver ( Observer * observer ) { for ( auto it = observer_list_ . begin (); it != observer_list_ . end (); it ++ ){ if ( * it == observer ){ observer_list_ . erase ( it ); return ; } } } void notifyObserver () { for ( auto it = observer_list_ . begin (); it != observer_list_ . end (); it ++ ){ ( * it ) -> update (); } } private : ConcreteSubjectA ( const ConcreteSubjectA & rhs ); ConcreteSubjectA & operator = ( const ConcreteSubjectA & rhs ); std :: vector < Observer *> observer_list_ ; }; int main () { ConcreteObserveA obser_a ; ConcreteObserveB obser_b ; ConcreteSubjectA suba ; std :: cerr << \"add two observer and update: \\n \" ; suba . registerObserver ( & obser_a ); suba . registerObserver ( & obser_b ); suba . notifyObserver (); std :: cout << \"remove obser_a and update: \\n \" ; suba . removeObserver ( & obser_a ); suba . notifyObserver (); return 0 ; } output: 1 2 3 4 5 add two observer and update: ConcreteObserveA::update ConcreteObserveB::update remove obser_a and update: ConcreteObserveB::update","title":"Observer Pattern"},{"location":"coding/system%26structure/several_design_patterns_by_cpp/#decorator-pattern","text":"Decorator pattern allows a user to add new functionality to an existing object without altering its structure. This type of design pattern comes under structural pattern as this pattern acts as a wrapper to existing class. This pattern creates a decorator class which wraps the original class and privides additional functionality keeping class methods signature inact; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 //By dexter @ 12/10/2020 #include <iostream> #include <string> #include <memory> class Component { public : explicit Component () {} Component ( const Component & rhs ) = delete ; Component & operator = ( const Component & rhs ) = delete ; virtual ~ Component () {} virtual std :: string methodA () = 0 ; virtual std :: string methodB () = 0 ; private : }; class ConcreteComponentA : public Component { public : ConcreteComponentA () : Component () {} ~ ConcreteComponentA () {} ConcreteComponentA ( const ConcreteComponentA & rhs ) = delete ; ConcreteComponentA & operator = ( const ConcreteComponentA & rhs ) = delete ; std :: string methodA (){ return \"ConcreteComponentA methodA\" ; } std :: string methodB (){ return \"ConcreteComponentA methodB\" ; } private : }; class Decorator : public Component { public : Decorator ( std :: shared_ptr < Component > component ) : component_ ( component ) {} ~ Decorator () {} Decorator ( const Decorator & rhs ) = delete ; Decorator & operator = ( const Decorator & rhs ) = delete ; std :: string methodA () { return component_ -> methodA (); } std :: string methodB () { return component_ -> methodB (); } private : protected : std :: shared_ptr < Component > component_ ; }; class ConcreteDecoratorA : public Decorator { public : ConcreteDecoratorA ( std :: shared_ptr < Component > component ) : Decorator ( component ) {} ~ ConcreteDecoratorA () {} ConcreteDecoratorA ( const ConcreteDecoratorA & rhs ) = delete ; ConcreteDecoratorA & operator = ( const ConcreteDecoratorA & rhs ) = delete ; std :: string methodA (){ return component_ -> methodA () + \" ConcreteDecoratorA methodA\" ; } std :: string methodB (){ return component_ -> methodB () + \" ConcreteDecoratorA methodB\" ; } private : }; class ConcreteDecoratorB : public Decorator { public : ConcreteDecoratorB ( std :: shared_ptr < Component > component ) : Decorator ( component ) {} ~ ConcreteDecoratorB () {} ConcreteDecoratorB ( const ConcreteDecoratorB & rhs ) = delete ; ConcreteDecoratorB & operator = ( const ConcreteDecoratorB & rhs ) = delete ; std :: string methodA (){ return component_ -> methodA () + \" ConcreteDecoratorB methodA\" ; } std :: string methodB (){ return component_ -> methodB () + \" ConcreteDecoratorB methodB\" ; } private : }; int main () { std :: shared_ptr < ConcreteComponentA > ptr_component_a = std :: make_shared < ConcreteComponentA > (); std :: cout << ptr_component_a -> methodA () << \", \" << ptr_component_a -> methodB () << std :: endl ; std :: shared_ptr < ConcreteDecoratorA > ptr_decorator_a = std :: make_shared < ConcreteDecoratorA > ( ptr_component_a ); std :: cout << ptr_decorator_a -> methodA () << \", \" << ptr_decorator_a -> methodB () << std :: endl ; std :: shared_ptr < ConcreteDecoratorB > ptr_decorator_b = std :: make_shared < ConcreteDecoratorB > ( ptr_component_a ); std :: cout << ptr_decorator_b -> methodA () << \", \" << ptr_decorator_b -> methodB () << std :: endl ; std :: shared_ptr < ConcreteDecoratorB > ptr_decorator_a_b = std :: make_shared < ConcreteDecoratorB > ( ptr_decorator_a ); std :: cout << ptr_decorator_a_b -> methodA () << \", \" << ptr_decorator_a_b -> methodB () << std :: endl ; return 0 ; } output: 1 2 3 4 ConcreteComponentA methodA, ConcreteComponentA methodB ConcreteComponentA methodA ConcreteDecoratorA methodA, ConcreteComponentA methodB ConcreteDecoratorA methodB ConcreteComponentA methodA ConcreteDecoratorB methodA, ConcreteComponentA methodB ConcreteDecoratorB methodB ConcreteComponentA methodA ConcreteDecoratorA methodA ConcreteDecoratorB methodA, ConcreteComponentA methodB ConcreteDecoratorA methodB ConcreteDecoratorB methodB","title":"Decorator Pattern"},{"location":"coding/system%26structure/several_design_patterns_by_cpp/#factory-pattern","text":"The factory pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact calss of the object that will be created. This is done by creating objects by calling a factory method, either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes rather than by calling a constructor. According to the type of problems, there are three kinds of Factory Pattern : - Simple Factory - Normal Factory - Abstract Factory","title":"Factory Pattern"},{"location":"coding/system%26structure/several_design_patterns_by_cpp/#simple-factory","text":"Simple Factory defines a method to create an object. It voilates the Open/close Principle(OCP) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 //By dexter @ 13/10/2020 #include <iostream> #include <string> #include <memory> class Product { public : explicit Product () {} virtual ~ Product () {} Product ( const Product & rhs ) = delete ; Product & operator = ( const Product & rhs ) = delete ; virtual void operation () = 0 ; }; class ConcreteProductA : public Product { public : explicit ConcreteProductA () : Product () {} ~ ConcreteProductA () {} ConcreteProductA ( const ConcreteProductA & rhs ) = delete ; ConcreteProductA & operator = ( const ConcreteProductA & rhs ) = delete ; void operation () { std :: cerr << \"ConcreteProductA is called...\" << std :: endl ; } }; class ConcreteProductB : public Product { public : explicit ConcreteProductB () : Product () {} ~ ConcreteProductB () {} ConcreteProductB ( const ConcreteProductB & rhs ) = delete ; ConcreteProductB & operator = ( const ConcreteProductB & rhs ) = delete ; void operation () { std :: cerr << \"ConcreteProductB is called...\" << std :: endl ; } }; class Factory { public : Factory () {} ~ Factory () {} Factory ( const Factory & rhs ) = delete ; Factory & operator = ( const Factory & rhs ) = delete ; std :: shared_ptr < Product > createProduct ( const std :: string & product ) { if ( product == \"A\" ) { return std :: make_shared < ConcreteProductA > (); } if ( product == \"B\" ) { return std :: make_shared < ConcreteProductB > (); } } }; int main () { Factory factory ; std :: shared_ptr < Product > product_a = factory . createProduct ( \"A\" ); std :: shared_ptr < Product > product_b = factory . createProduct ( \"B\" ); product_a -> operation (); product_b -> operation (); return 0 ; } output: 1 2 ConcreteProductA is called... ConcreteProductB is called...","title":"Simple Factory"},{"location":"coding/system%26structure/several_design_patterns_by_cpp/#normal-factory","text":"Normal Factory not only encapsulates the creation of object but also put the creation of object into derived class. It only provides the method of creating objects, and the realization is in ConcreteFactory . Disadvantage: the addition of factory object will cause the increasing of classes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 //By dexter @ 13/10/2020 #include <iostream> #include <string> #include <memory> class Product { public : explicit Product () {} virtual ~ Product () {} Product ( const Product & rhs ) = delete ; Product & operator = ( const Product & rhs ) = delete ; virtual void operation () = 0 ; }; class ConcreteProductA : public Product { public : explicit ConcreteProductA () : Product () {} ~ ConcreteProductA () {} ConcreteProductA ( const ConcreteProductA & rhs ) = delete ; ConcreteProductA & operator = ( const ConcreteProductA & rhs ) = delete ; void operation () { std :: cerr << \"ConcreteProductA is called...\" << std :: endl ; } }; class ConcreteProductB : public Product { public : explicit ConcreteProductB () : Product (){} ~ ConcreteProductB () {} ConcreteProductB ( const ConcreteProductB & rhs ) = delete ; ConcreteProductB & operator = ( const ConcreteProductB & rhs ) = delete ; void operation () { std :: cerr << \"ConcreteProductB is called...\" << std :: endl ; } }; class Factory { public : explicit Factory () {} virtual ~ Factory () {} Factory ( const Factory & rhs ) = delete ; Factory & operator = ( const Factory & rhs ) = delete ; virtual std :: shared_ptr < Product > createProduct () = 0 ; }; class ConcreteFactoryA : public Factory { public : explicit ConcreteFactoryA () : Factory () {} ~ ConcreteFactoryA () {} ConcreteFactoryA ( const ConcreteFactoryA & rhs ) = delete ; ConcreteFactoryA & operator = ( const ConcreteFactoryA & rhs ) = delete ; std :: shared_ptr < Product > createProduct () { return std :: make_shared < ConcreteProductA > (); } }; class ConcreteFactoryB : public Factory { public : explicit ConcreteFactoryB () : Factory () {} ~ ConcreteFactoryB () {} ConcreteFactoryB ( const ConcreteFactoryB & rhs ) = delete ; ConcreteFactoryB & operator = ( const ConcreteFactoryB & rhs ) = delete ; std :: shared_ptr < Product > createProduct () { return std :: make_shared < ConcreteProductB > (); } }; int main () { auto factor_a = std :: make_shared < ConcreteFactoryA > (); auto product_a = factor_a -> createProduct (); product_a -> operation (); auto factor_b = std :: make_shared < ConcreteFactoryB > (); auto product_b = factor_b -> createProduct (); product_b -> operation (); return 0 ; } output: 1 2 ConcreteProductA is called... ConcreteProductB is called...","title":"Normal Factory"},{"location":"coding/system%26structure/uml_graph/","text":"This page is the note of Bjarne's speech at Edinburgh from youtobe.","title":"UML Graphic"},{"location":"dairy/note-no-valience-chatting/","text":"\u9605\u8bfb\u300a\u975e\u66b4\u529b\u6c9f\u901a\u300b\u6458\u8981. \u7559\u610f \u53cc\u8d62\u601d\u7ef4(THINK WIN/WIN) \u53cc\u8d62\u601d\u7ef4\u662f\u4e00\u79cd\u57fa\u4e8e\u4e92\u656c\u4e92\u60e0\u7684\u601d\u8003\u6846\u67b6\uff0c\u76ee\u7684\u662f\u66f4\u4e30\u76db\u7684\u673a\u4f1a\u3001\u8d22\u5bcc\u548c\u8d44\u6e90\uff0c\u800c\u975e\u654c\u5bf9\u5f0f\u7684\u7ade\u4e89 \u77e5\u5f7c\u89e3\u5df1(SEEK FIRST TO UNDERSTND,THEN TO BE UNDERSTOOD) \u5f53\u6211\u4eec\u820d\u5f03\u56de\u7b54\u5fc3\uff0c\u6539\u4ee5\u4e86\u89e3\u53bb\u8046\u542c\u522b\u4eba\uff0c\u4fbf\u80fd\u5f00\u542f\u771f\u6b63\u7684\u6c9f\u901a\uff0c\u589e\u8fdb\u5f7c\u6b64\u5173\u7cfb\u3002 \u7edf\u5408\u7efc\u6548(SYNERGIZE) \u7edf\u5408\u7efc\u6548\u610f\u601d\u662f\u521b\u9020\u7b2c\u4e09\u79cd\u9009\u62e9-\u975e\u6309\u7167\u6211\u7684\u65b9\u5f0f\uff0c\u4e5f\u975e\u9075\u5faa\u4f60\u7684\u65b9\u5f0f\uff0c\u800c\u662f\u7b2c\u4e09\u79cd\u8fdc\u80dc\u4e8e\u4e2a\u4eba\u4e4b\u89c1\u7684\u65b9\u6cd5\u3002\u654c\u5bf9\u7684\u6001\u5ea6(1+1=\u00bd),\u4e0d\u59a5\u534f\u4e3a\u76ee\u6807(1+1=3/2)\uff0c\u6d45\u5c42\u5408\u4f5c(1+1=2),\u521b\u9020\u5f0f\u5408\u4f5c(1+1>2) \u4e0d\u65ad\u66f4\u65b0(SHARPEN THE SAW) \u5373\u5728\u56db\u4e2a\u57fa\u672c\u751f\u6d3b\u5c42\u9762(\u8eab\u4f53\u3001\u7cbe\u795e\u3001\u667a\u529b\u3001\u793e\u4f1a/\u60c5\u611f)\u4e0d\u65ad\u7684\u66f4\u65b0\u8fed\u4ee3\u81ea\u5df1\u3002 \u6050\u6016\u611f\u548c\u4e0d\u5b89\u5168\u611f \u6211\u73b0\u5728\u5c31\u50cf\u5f97\u5230 \u8c34\u8d23\u548c\u62b1\u6028 \u7edd\u671b\u65e0\u52a9 \u7f3a\u4e4f\u4eba\u751f\u5e73\u8861 \u6211\u7684\u5b9a\u4f4d\u5728\u54ea\u513f \u6e34\u671b\u7406\u89e3 \u51b2\u7a81\u548c\u5206\u6b67 \u4e2a\u4eba\u7684\u505c\u6ede\u4e0d\u524d","title":"\u8bfb\u4e66\u7b14\u8bb0:\u975e\u66b4\u529b\u6c9f\u901a"},{"location":"dairy/note-the-seven-habits-of-effective-awosome/","text":"\u9605\u8bfb\u300a\u9ad8\u6548\u4eba\u58eb\u7684\u4e03\u4e2a\u4e60\u60ef\u300b\u6458\u8981. \u79ef\u6781\u4e3b\u52a8(BE PROACTIVE) \u4e3b\u52a8\u79ef\u6781\u5373\u91c7\u53d6\u884c\u52a8\uff0c\u4e3a\u81ea\u5df1\u7684\u8fc7\u53bb\u3001\u73b0\u5728\u3001\u672a\u6765\u7684\u884c\u4e3a\u8d1f\u8d23\uff0c\u5e76\u4f9d\u636e\u539f\u5219\u548c\u4ef7\u503c\u89c2\u800c\u975e\u60c5\u7eea\u6216\u5916\u5728\u73af\u5883\u6765\u505a\u51b3\u5b9a\u3002 \u4ee5\u7ec8\u4e3a\u59cb(BEGIN WITH THE END IN MIND) \u6240\u6709\u4e8b\u7269\u90fd\u7ecf\u8fc7\u4e24\u6b21\u521b\u9020-\u5148\u7ecf\u8fc7\u8111\u6d77\u7684\u915d\u917f\u548c\u9884\u6f14\uff0c\u5176\u6b21\u624d\u662f\u5b9e\u8d28\u6027\u7684\u521b\u9020\u3002 \u8981\u4e8b\u7b2c\u4e00(PUT FIRST THINGS FIRST) \u8981\u4e8b\u7b2c\u4e00\u5373\u5b9e\u8d28\u7684\u521b\u9020\uff0c\u662f\u68a6\u60f3(\u4f60\u7684\u76ee\u6807\u3001\u4ef7\u503c\u89c2\u53ca\u8981\u4e8b\u5904\u7406\u7684\u987a\u5e8f)\u7684\u7ec4\u7ec7\u548c\u5b9e\u8df5\u3002 \u53cc\u8d62\u601d\u7ef4(THINK WIN/WIN) \u53cc\u8d62\u601d\u7ef4\u662f\u4e00\u79cd\u57fa\u4e8e\u4e92\u656c\u4e92\u60e0\u7684\u601d\u8003\u6846\u67b6\uff0c\u76ee\u7684\u662f\u66f4\u4e30\u76db\u7684\u673a\u4f1a\u3001\u8d22\u5bcc\u548c\u8d44\u6e90\uff0c\u800c\u975e\u654c\u5bf9\u5f0f\u7684\u7ade\u4e89 \u77e5\u5f7c\u89e3\u5df1(SEEK FIRST TO UNDERSTND,THEN TO BE UNDERSTOOD) \u5f53\u6211\u4eec\u820d\u5f03\u56de\u7b54\u5fc3\uff0c\u6539\u4ee5\u4e86\u89e3\u53bb\u8046\u542c\u522b\u4eba\uff0c\u4fbf\u80fd\u5f00\u542f\u771f\u6b63\u7684\u6c9f\u901a\uff0c\u589e\u8fdb\u5f7c\u6b64\u5173\u7cfb\u3002 \u7edf\u5408\u7efc\u6548(SYNERGIZE) \u7edf\u5408\u7efc\u6548\u610f\u601d\u662f\u521b\u9020\u7b2c\u4e09\u79cd\u9009\u62e9-\u975e\u6309\u7167\u6211\u7684\u65b9\u5f0f\uff0c\u4e5f\u975e\u9075\u5faa\u4f60\u7684\u65b9\u5f0f\uff0c\u800c\u662f\u7b2c\u4e09\u79cd\u8fdc\u80dc\u4e8e\u4e2a\u4eba\u4e4b\u89c1\u7684\u65b9\u6cd5\u3002\u654c\u5bf9\u7684\u6001\u5ea6(1+1=\u00bd),\u4e0d\u59a5\u534f\u4e3a\u76ee\u6807(1+1=3/2)\uff0c\u6d45\u5c42\u5408\u4f5c(1+1=2),\u521b\u9020\u5f0f\u5408\u4f5c(1+1>2) \u4e0d\u65ad\u66f4\u65b0(SHARPEN THE SAW) \u5373\u5728\u56db\u4e2a\u57fa\u672c\u751f\u6d3b\u5c42\u9762(\u8eab\u4f53\u3001\u7cbe\u795e\u3001\u667a\u529b\u3001\u793e\u4f1a/\u60c5\u611f)\u4e0d\u65ad\u7684\u66f4\u65b0\u8fed\u4ee3\u81ea\u5df1\u3002 \u6050\u6016\u611f\u548c\u4e0d\u5b89\u5168\u611f \u6211\u73b0\u5728\u5c31\u50cf\u5f97\u5230 \u8c34\u8d23\u548c\u62b1\u6028 \u7edd\u671b\u65e0\u52a9 \u7f3a\u4e4f\u4eba\u751f\u5e73\u8861 \u6211\u7684\u5b9a\u4f4d\u5728\u54ea\u513f \u6e34\u671b\u7406\u89e3 \u51b2\u7a81\u548c\u5206\u6b67 \u4e2a\u4eba\u7684\u505c\u6ede\u4e0d\u524d","title":"\u8bfb\u4e66\u7b14\u8bb0:\u9ad8\u6548\u4eba\u58eb\u7684\u4e03\u4e2a\u4e60\u60ef"},{"location":"m%26l/filter_eskf_tmp/","text":"note of eskf ESKF error-state\u6700\u5c0f\u8f7b\u91cf\u5316,\u53c2\u6570\u548c\u81ea\u7531\u5ea6\u4e00\u6837\uff0c\u4f46\u662f\u907f\u514d\u4e86\u53c2\u6570\u5316\u5197\u4f59(\u5373\u5f3a\u7ea6\u675f\u8ba1\u7b97\u65f6\u53ef\u80fd\u968f\u4e4b\u800c\u6765\u7684\u534f\u65b9\u5dee\u5947\u5f02\u6027\u7684\u95ee\u9898) error-state\u603b\u662f\u4fdd\u6301\u8bef\u5dee\u5904\u57280\u503c\u9644\u8fd1\uff0c\u907f\u514d\u6f5c\u5728\u7684\u53c2\u6570\u5947\u5f02\u6027\u3001\u4e07\u5411\u9501\u95ee\u9898/ \u80fd\u4fdd\u8bc1\u4efb\u4f55\u65f6\u523b\u6709\u6548\u7ebf\u6027\u5316 error-state\u8db3\u591f\u5c0f,\u610f\u5473\u7740\u5176\u4e8c\u9636\u5bfc\u57fa\u672c\u53ef\u5ffd\u7565\uff0cJacobian\u8ba1\u7b97\u4f1a\u5f88\u5bb9\u6613\u5f88\u5feb\u6216\u8005Jacobian\u662f\u6052\u5b9a\u7684 todo ESKF\u57fa\u672c\u4ecb\u7ecd \u00b6 \u72b6\u6001\u91cf\u5305\u62ec true-state / nominal-state / error-state 1. \u9ad8\u9891IMU\u6570\u636e \\(u_m\\) \u96c6\u6210\u5230 nominal-state \\(x\\) , \u4e0d\u8003\u8651\u566a\u58f0\u9879\u76ee \\(w\\) \u548c\u5176\u4ed6\u6270\u52a8 2. \u5b9e\u65f6\u7d2f\u8ba1\u7684\u8bef\u5dee\u96c6\u6210\u5230 error-state (\u7531\u5c0f\u7684\u4fe1\u53f7\u72b6\u6001\u91cf\u6784\u6210,\u6709\u65f6\u5e8f\u7684\u52a8\u6001\u7ebf\u6027\u7cfb\u7edf\u8fdb\u884c correct ,\u7528\u5230\u7684\u63a7\u5236\u53ca\u6d4b\u91cf\u77e9\u9635\u7531 nominal-state \u8ba1\u7b97) \\(\\delta x\\) \u5e76\u7528ESKF\u8bc4\u4f30(\u5305\u542b\u4e86\u6240\u6709\u7684\u566a\u58f0\u9879\u548c\u6270\u52a8) 3. nominal-state \u96c6\u6210\u7684\u540c\u65f6,ESKF\u4f1a prdict \u4e00\u4e2a error-state \u7684\u9ad8\u65af\u4f30\u8ba1 4. \u7cbe\u5ea6\u9ad8\u4e8eIMU\u7684 anchor-msg (rtk/lidar/vision)\u5230\u8fbe\u65f6\u5bf9 error\u2014state \u8fdb\u884c correct ,\u4ece\u800c\u8ba1\u7b97\u51fa\u4e00\u4e2a\u540e\u9a8c\u7684 error-state \u7684\u9ad8\u65af\u4f30\u8ba1,\u6700\u540e\u5c06 error-state \u7684\u5747\u503c\u6ce8\u5165\u5230 nominal-state \u540e\u91cd\u7f6e\u4e3a0, error-state \u7684\u534f\u65b9\u5dee..... ErrorState \u00b6 \\[ ErrorState=\\begin{bmatrix} VarType \\quad error\\_{var} \\\\\\\\ CovType \\quad error\\_state\\_cov \\quad state\\_progation \\quad propagated\\_noise\\_cov \\\\\\\\ double \\quad beta\\_{coefficient} \\end{bmatrix} $$ ### CoreState $$ CoreState=\\begin{bmatrix} P \\\\\\\\ V \\\\\\\\ Q \\\\\\\\ Ba \\\\\\\\ Bg \\\\\\\\ ErrorState \\\\\\\\ double \\quad beta\\_{coefficient} \\end{bmatrix} \\]","title":"Note after reading paper of ESKF"},{"location":"m%26l/filter_eskf_tmp/#eskf","text":"\u72b6\u6001\u91cf\u5305\u62ec true-state / nominal-state / error-state 1. \u9ad8\u9891IMU\u6570\u636e \\(u_m\\) \u96c6\u6210\u5230 nominal-state \\(x\\) , \u4e0d\u8003\u8651\u566a\u58f0\u9879\u76ee \\(w\\) \u548c\u5176\u4ed6\u6270\u52a8 2. \u5b9e\u65f6\u7d2f\u8ba1\u7684\u8bef\u5dee\u96c6\u6210\u5230 error-state (\u7531\u5c0f\u7684\u4fe1\u53f7\u72b6\u6001\u91cf\u6784\u6210,\u6709\u65f6\u5e8f\u7684\u52a8\u6001\u7ebf\u6027\u7cfb\u7edf\u8fdb\u884c correct ,\u7528\u5230\u7684\u63a7\u5236\u53ca\u6d4b\u91cf\u77e9\u9635\u7531 nominal-state \u8ba1\u7b97) \\(\\delta x\\) \u5e76\u7528ESKF\u8bc4\u4f30(\u5305\u542b\u4e86\u6240\u6709\u7684\u566a\u58f0\u9879\u548c\u6270\u52a8) 3. nominal-state \u96c6\u6210\u7684\u540c\u65f6,ESKF\u4f1a prdict \u4e00\u4e2a error-state \u7684\u9ad8\u65af\u4f30\u8ba1 4. \u7cbe\u5ea6\u9ad8\u4e8eIMU\u7684 anchor-msg (rtk/lidar/vision)\u5230\u8fbe\u65f6\u5bf9 error\u2014state \u8fdb\u884c correct ,\u4ece\u800c\u8ba1\u7b97\u51fa\u4e00\u4e2a\u540e\u9a8c\u7684 error-state \u7684\u9ad8\u65af\u4f30\u8ba1,\u6700\u540e\u5c06 error-state \u7684\u5747\u503c\u6ce8\u5165\u5230 nominal-state \u540e\u91cd\u7f6e\u4e3a0, error-state \u7684\u534f\u65b9\u5dee.....","title":"ESKF\u57fa\u672c\u4ecb\u7ecd"},{"location":"m%26l/filter_eskf_tmp/#errorstate","text":"\\[ ErrorState=\\begin{bmatrix} VarType \\quad error\\_{var} \\\\\\\\ CovType \\quad error\\_state\\_cov \\quad state\\_progation \\quad propagated\\_noise\\_cov \\\\\\\\ double \\quad beta\\_{coefficient} \\end{bmatrix} $$ ### CoreState $$ CoreState=\\begin{bmatrix} P \\\\\\\\ V \\\\\\\\ Q \\\\\\\\ Ba \\\\\\\\ Bg \\\\\\\\ ErrorState \\\\\\\\ double \\quad beta\\_{coefficient} \\end{bmatrix} \\]","title":"ErrorState"},{"location":"m%26l/filter_kalman/","text":"The content mainly reference from yongcongwang's IMM Prediction The Kalman filter which was published by R.E.Kalman in 1960, is a set of mathematical equations that provides an efficient computational (recursive) means to estimate the state of a process, in a way that minimizes the mean of the squared error. The filter is very powerful in several aspects: it supports estimations of past, present, and even future states, and it can do so even when the precise nature of the modeled system is unknown. Basic Equations \u00b6 overview $$ \\begin{aligned} \\underset{n \\times 1}{X_k} &= \\underset{n \\times n}{A}\\underset{n \\times 1}{X_{k-1}} + \\underset{n \\times b}{B} \\underset{b \\times 1}{U_{k-1}} + \\underset{n \\times 1}{w_{k-1}}\\,(Q)\\\\ \\underset{m \\times 1}{Z_k} &= \\underset{m \\times n}{H}\\underset{n \\times 1}{X_k} + \\underset{m \\times 1}{v_{k}}\\,(R) \\end{aligned} $$ predict $$ \\begin{aligned} \\underset{n \\times 1}{X_k^{pre}} &= \\underset{n \\times n}{A} \\cdot \\underset{n \\times 1}{X_{k-1}} + \\underset{n \\times b}{B} \\cdot \\underset{b \\times 1}{U_{k-1}}\\\\ \\underset{n \\times n}{P_k^{pre}} &= \\underset{n \\times n}{A} \\cdot \\underset{n \\times n}{P_{k-1}} \\cdot \\underset{n \\times n}{A^T} + \\underset{n \\times n}{Q} \\end{aligned} $$ correct $$ \\begin{aligned} \\mathcal{K_{n \\times m}} &= (P {pre}_kH T) \\cdot (HP {pre}_kH T + R)^{-1} \\\\ X_k &= X^{pre}_k + \\mathcal{K}(Z_k- HX^{pre}_k) \\\\ P_k &= (I - \\mathcal{K}H)P^{pre}_k \\end{aligned} $$ The process to be estimated \u00b6 The Kalman filter addressed the general problem of trying to estimate the state \\(x\\in \\Re^n\\) of a discrete-time controlled process that is governed by the linear stochastic difference equation: $$ x_k = Ax_{k-1} + Bu_{k-1} + w_{k-1} \\qquad p(w) \\sim N(0, Q) \\tag{1} $$ with a measurement \\(z \\in \\Re^m\\) that is: $$ z_k = Hx_k + v_k \\qquad p(v) \\sim N(0,R) \\tag{2} $$ - The \\(n*n\\) matrix \\(A\\) is transition matrix which relates the state at the previous time step \\(k-1\\) to the state at the current step \\(k\\) , in the absence of either a driving function or process noise. Note that in practice \\(A\\) might change with each time step, but here we assume it is constant. - The \\(n *1\\) matrix \\(B\\) is control matrix which relates the optional control input \\(u \\in \\Re^l\\) to the state \\(x\\) . - The \\(m *n\\) matrix \\(H\\) is measurement matrix which relates the state to the measurement \\(z_k\\) . In practice \\(H\\) might change with each time step, but here we also assume it is constant. - The random variable \\(w_{k-1}\\) and \\(v_k\\) represent the process and measurement noise. They are assumed to be independent(of each other), it belongs to gauss-white noise with normal probability distributions. and \\(Q\\) is process noise covariance and \\(R\\) is measurement noise covariance , they might change with each time step, but we assume they are both constant. The computational origin of the filter \u00b6 We define \\(\\hat{x}\\_k^- \\in \\Re^n\\) to be our priori state estimate at step \\(k\\) given knowledge of the process priori to step \\(k\\) and \\(\\hat{x}\\_k \\in \\Re^n\\) to be our posteriori state estimate at step \\(k\\) given measurement \\(z_k\\) . we also define \\(x_k\\) is the ground truth, then we can get a priori and a posteriori estimate errors as: $$ prio estimate error: e_k^- \\equiv x_k - \\hat{x}_k^- \\tag{3} $$ $$ post estimate error: e_k \\equiv x_k - \\hat{x}_k \\tag{4} $$ The priori estimate error covariance is: $$ P_k^- = E[e_k -(e_k -)^T] \\tag{5} $$ The posteriori estimate error covariance is: $$ P_k = E[e_ke_k^T] \\tag{6} $$ In deriving the equation for the kalman filter, we begin with the goal of finding an equation that compute an posteriori state estimate \\(\\hat{x}\\_k\\) as a linear combination of the priori estimate \\(\\hat{x}\\_k^-\\) and a weighted difference between an actual measurement \\(z\\_k\\) and a prediction of the measurement \\(H\\hat{x}\\_k^-\\) as show below: $$ \\hat{x}_k = \\hat{x}_k^- + K(z_k - H\\hat{x}_k^-) \\tag7 $$ The difference \\((z\\_k - H\\hat{x}\\_k^-)\\) is called the measurement innovation or residual . The residual reflects the discrepency bewteen the predicted measurement \\(H\\hat{x}\\_k^-\\) and the actual measurement \\(z_k\\) . A residual of zero means that the two are in complete agreement. The \\(n*m\\) matrix \\(K\\) is chosen to be the gain or blending factor that minimizes the posteriori error covariance in (6). This minimization can be accomplished by: 1. substituting (7) into the (4) and substituting that into (6); 2. performing the indicated expectation; 3. taking the derivative of the trace of the result with respect to \\(K\\) ; 4. setting the result equal to \\(0\\) and then solving for \\(K\\) . One form of the resulting \\(K\\) that minimized (6) is: \\[ \\begin{aligned} K_k &= P_k^-H^T(HP_k^-H^T \\ +\\ R )^{-1} \\\\\\\\ &= \\frac{P_k^-H^T}{HP_k^-H^T \\ +\\ R } \\end{aligned} \\tag{8} \\] Looking at (10) we see that as the measurement error covariance \\(R \\to 0\\) , the gain \\(K\\) weights the residual more heavily.Specially, $$ \\lim_{R_k \\to 0}K_k = H^{-1} \\tag{9} $$ On the other hand, as the priori estimate error covariance \\(P_k^- \\to 0\\) , the gain \\(K\\) weights the residual less heavily.Specially, $$ \\lim_{P_k^- \\to 0}K_k = 0 \\tag{10} $$ Another way of thinking about the weighting by \\(K\\) is that as the measurement error covariance \\(R \\to 0\\) , the actual measurement \\(z_k\\) is more trusted , while the predicted mesaurement \\(H\\hat{x}_k^-\\) is less trusted . On the other hand, as the priori estimate error covariance \\(P_k^- \\to 0\\) , the actual measurement \\(z_k\\) is less trusted , while the predicted measurement \\(H\\hat{x}_k^-\\) is more trusted . The discrete Kalman Filter Algorithm \u00b6 The kalman filter estimate a process by using a form of feedback control: the filter estimates the process state at some time and then obtains feedback in the form of (noisy) measurement. As such, the equations for the Kalman filter falls into two groups: - time update (predict) equations; - measurement update (correct) equations; The time update equations are responsible for projecting forwar(in time) the current state and error covariance estimates to obtain the prior estimates for the next time step. The measurement update equations are responsible for the feedback, incorporating a new measurement into the priori estimate to obtain an improved posterori estimate. The final estimation algorithm resembles that of a predictor->corrector algorithm for solving numerical problems: 1 2 3 4 5 Time Update -----> Measurement Update (Predict) (Correct) ^ | | | ----------------------- The specific equations for the time update(predictor) are: $$ \\hat{x}_k^- = A\\hat{x}_{k-1} + Bu_{k-1} \\tag{11} $$ $$ P_k^- = AP_{k-1}A^T + Q \\tag{12} $$ where: - \\(\\hat{x}\\_{k-1}\\) is the posteriori state from time step \\(k-1\\) ; - \\(u\\_{k-1}\\) is the control from time step \\(k-1\\) ; - \\(\\hat{x}\\_k^-\\) is the priori state from time step \\(k\\) ; - \\(P_{k-1}\\) is the posterirori estimate error covariance from time step \\(k-1\\) ; - \\(P_k^-\\) is the priori estimate error covariance from time step \\(k\\) ; The specific equations for the measurement update(corrector) are: $$ K_k = P_k -H T \\cdot (HP_k -H T + R)^{-1} \\tag{13} $$ $$ \\hat{x}_k = \\hat{x}_k^- + K_k\\cdot (z_k - H\\hat{x}_k^-) \\tag{14} $$ $$ P_k= (I - K_kH) \\cdot P_k^- \\tag{15} $$ where: - \\(K_k\\) is the gain from time step \\(k\\) ; - \\(z_k\\) is the actual measurement variable from time step \\(k\\) ; - \\(\\hat{x}\\_k\\) is the posteriori state from time step \\(k\\) ; - \\(P_k\\) is the posteriori estimate error covariance from time step \\(k\\) ; Python of Kalman Filter \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class KalmanFilter : def __init__ ( self , A , B , H , Q , R ): self . A = A self . B = B self . H = H self . Q = Q self . R = R self . U = np . zeros (( B . shape [ 1 ], 1 )) self . X = np . zeros (( A . shape [ 0 ], 1 )) self . X_pre = self . X self . P = np . zeros ( A . shape ) self . P_pre = self . P def __init__ ( self , A , H ): self . A = A self . X = np . zeros (( A . shape [ 0 ], 1 )) self . B = np . eye ( A . shape [ 0 ]) self . U = np . zeros (( self . B . shape [ 1 ], 1 )) self . Q = np . eye ( A . shape [ 0 ]) self . H = H self . R = np . eye ( H . shape [ 0 ]) self . X_pre = self . X self . P = np . zeros ( A . shape ) self . P_pre = self . P def filt ( self , Z ): \"\"\" x = A*x + B*u +Q y = H*x + R \"\"\" self . __predict () self . __update ( Z ) return self . X def __predict ( self ): \"\"\" x_next = A*x + B*u P_next = A*P*AT + Q \"\"\" self . X_pre = np . dot ( self . A , self . X ) + np . dot ( self . B , self . U ) self . P_pre = np . dot ( np . dot ( self . A , self . P ), self . A . T ) + self . Q def __update ( self , Z ): \"\"\" K = (P_next*HT) * (H*P_next*HT + R).inverse() x = x_next + K*(z - H*x_next) P = P_next - K*H*P_next \"\"\" K = np . dot ( np . dot ( self . P_pre , self . H . T ), np . linalg . inv ( np . dot ( np . dot ( self . H , self . P_pre ), self . H . T ) + self . R )) self . X = self . X_pre + np . dot ( K , Z - np . dot ( self . H , self . X_pre )) self . P = self . P_pre - np . dot ( np . dot ( K , self . H ), self . P_pre )","title":"Introduction of Kalman Filter"},{"location":"m%26l/filter_kalman/#basic-equations","text":"overview $$ \\begin{aligned} \\underset{n \\times 1}{X_k} &= \\underset{n \\times n}{A}\\underset{n \\times 1}{X_{k-1}} + \\underset{n \\times b}{B} \\underset{b \\times 1}{U_{k-1}} + \\underset{n \\times 1}{w_{k-1}}\\,(Q)\\\\ \\underset{m \\times 1}{Z_k} &= \\underset{m \\times n}{H}\\underset{n \\times 1}{X_k} + \\underset{m \\times 1}{v_{k}}\\,(R) \\end{aligned} $$ predict $$ \\begin{aligned} \\underset{n \\times 1}{X_k^{pre}} &= \\underset{n \\times n}{A} \\cdot \\underset{n \\times 1}{X_{k-1}} + \\underset{n \\times b}{B} \\cdot \\underset{b \\times 1}{U_{k-1}}\\\\ \\underset{n \\times n}{P_k^{pre}} &= \\underset{n \\times n}{A} \\cdot \\underset{n \\times n}{P_{k-1}} \\cdot \\underset{n \\times n}{A^T} + \\underset{n \\times n}{Q} \\end{aligned} $$ correct $$ \\begin{aligned} \\mathcal{K_{n \\times m}} &= (P {pre}_kH T) \\cdot (HP {pre}_kH T + R)^{-1} \\\\ X_k &= X^{pre}_k + \\mathcal{K}(Z_k- HX^{pre}_k) \\\\ P_k &= (I - \\mathcal{K}H)P^{pre}_k \\end{aligned} $$","title":"Basic Equations"},{"location":"m%26l/filter_kalman/#the-process-to-be-estimated","text":"The Kalman filter addressed the general problem of trying to estimate the state \\(x\\in \\Re^n\\) of a discrete-time controlled process that is governed by the linear stochastic difference equation: $$ x_k = Ax_{k-1} + Bu_{k-1} + w_{k-1} \\qquad p(w) \\sim N(0, Q) \\tag{1} $$ with a measurement \\(z \\in \\Re^m\\) that is: $$ z_k = Hx_k + v_k \\qquad p(v) \\sim N(0,R) \\tag{2} $$ - The \\(n*n\\) matrix \\(A\\) is transition matrix which relates the state at the previous time step \\(k-1\\) to the state at the current step \\(k\\) , in the absence of either a driving function or process noise. Note that in practice \\(A\\) might change with each time step, but here we assume it is constant. - The \\(n *1\\) matrix \\(B\\) is control matrix which relates the optional control input \\(u \\in \\Re^l\\) to the state \\(x\\) . - The \\(m *n\\) matrix \\(H\\) is measurement matrix which relates the state to the measurement \\(z_k\\) . In practice \\(H\\) might change with each time step, but here we also assume it is constant. - The random variable \\(w_{k-1}\\) and \\(v_k\\) represent the process and measurement noise. They are assumed to be independent(of each other), it belongs to gauss-white noise with normal probability distributions. and \\(Q\\) is process noise covariance and \\(R\\) is measurement noise covariance , they might change with each time step, but we assume they are both constant.","title":"The process to be estimated"},{"location":"m%26l/filter_kalman/#the-computational-origin-of-the-filter","text":"We define \\(\\hat{x}\\_k^- \\in \\Re^n\\) to be our priori state estimate at step \\(k\\) given knowledge of the process priori to step \\(k\\) and \\(\\hat{x}\\_k \\in \\Re^n\\) to be our posteriori state estimate at step \\(k\\) given measurement \\(z_k\\) . we also define \\(x_k\\) is the ground truth, then we can get a priori and a posteriori estimate errors as: $$ prio estimate error: e_k^- \\equiv x_k - \\hat{x}_k^- \\tag{3} $$ $$ post estimate error: e_k \\equiv x_k - \\hat{x}_k \\tag{4} $$ The priori estimate error covariance is: $$ P_k^- = E[e_k -(e_k -)^T] \\tag{5} $$ The posteriori estimate error covariance is: $$ P_k = E[e_ke_k^T] \\tag{6} $$ In deriving the equation for the kalman filter, we begin with the goal of finding an equation that compute an posteriori state estimate \\(\\hat{x}\\_k\\) as a linear combination of the priori estimate \\(\\hat{x}\\_k^-\\) and a weighted difference between an actual measurement \\(z\\_k\\) and a prediction of the measurement \\(H\\hat{x}\\_k^-\\) as show below: $$ \\hat{x}_k = \\hat{x}_k^- + K(z_k - H\\hat{x}_k^-) \\tag7 $$ The difference \\((z\\_k - H\\hat{x}\\_k^-)\\) is called the measurement innovation or residual . The residual reflects the discrepency bewteen the predicted measurement \\(H\\hat{x}\\_k^-\\) and the actual measurement \\(z_k\\) . A residual of zero means that the two are in complete agreement. The \\(n*m\\) matrix \\(K\\) is chosen to be the gain or blending factor that minimizes the posteriori error covariance in (6). This minimization can be accomplished by: 1. substituting (7) into the (4) and substituting that into (6); 2. performing the indicated expectation; 3. taking the derivative of the trace of the result with respect to \\(K\\) ; 4. setting the result equal to \\(0\\) and then solving for \\(K\\) . One form of the resulting \\(K\\) that minimized (6) is: \\[ \\begin{aligned} K_k &= P_k^-H^T(HP_k^-H^T \\ +\\ R )^{-1} \\\\\\\\ &= \\frac{P_k^-H^T}{HP_k^-H^T \\ +\\ R } \\end{aligned} \\tag{8} \\] Looking at (10) we see that as the measurement error covariance \\(R \\to 0\\) , the gain \\(K\\) weights the residual more heavily.Specially, $$ \\lim_{R_k \\to 0}K_k = H^{-1} \\tag{9} $$ On the other hand, as the priori estimate error covariance \\(P_k^- \\to 0\\) , the gain \\(K\\) weights the residual less heavily.Specially, $$ \\lim_{P_k^- \\to 0}K_k = 0 \\tag{10} $$ Another way of thinking about the weighting by \\(K\\) is that as the measurement error covariance \\(R \\to 0\\) , the actual measurement \\(z_k\\) is more trusted , while the predicted mesaurement \\(H\\hat{x}_k^-\\) is less trusted . On the other hand, as the priori estimate error covariance \\(P_k^- \\to 0\\) , the actual measurement \\(z_k\\) is less trusted , while the predicted measurement \\(H\\hat{x}_k^-\\) is more trusted .","title":"The computational origin of the filter"},{"location":"m%26l/filter_kalman/#the-discrete-kalman-filter-algorithm","text":"The kalman filter estimate a process by using a form of feedback control: the filter estimates the process state at some time and then obtains feedback in the form of (noisy) measurement. As such, the equations for the Kalman filter falls into two groups: - time update (predict) equations; - measurement update (correct) equations; The time update equations are responsible for projecting forwar(in time) the current state and error covariance estimates to obtain the prior estimates for the next time step. The measurement update equations are responsible for the feedback, incorporating a new measurement into the priori estimate to obtain an improved posterori estimate. The final estimation algorithm resembles that of a predictor->corrector algorithm for solving numerical problems: 1 2 3 4 5 Time Update -----> Measurement Update (Predict) (Correct) ^ | | | ----------------------- The specific equations for the time update(predictor) are: $$ \\hat{x}_k^- = A\\hat{x}_{k-1} + Bu_{k-1} \\tag{11} $$ $$ P_k^- = AP_{k-1}A^T + Q \\tag{12} $$ where: - \\(\\hat{x}\\_{k-1}\\) is the posteriori state from time step \\(k-1\\) ; - \\(u\\_{k-1}\\) is the control from time step \\(k-1\\) ; - \\(\\hat{x}\\_k^-\\) is the priori state from time step \\(k\\) ; - \\(P_{k-1}\\) is the posterirori estimate error covariance from time step \\(k-1\\) ; - \\(P_k^-\\) is the priori estimate error covariance from time step \\(k\\) ; The specific equations for the measurement update(corrector) are: $$ K_k = P_k -H T \\cdot (HP_k -H T + R)^{-1} \\tag{13} $$ $$ \\hat{x}_k = \\hat{x}_k^- + K_k\\cdot (z_k - H\\hat{x}_k^-) \\tag{14} $$ $$ P_k= (I - K_kH) \\cdot P_k^- \\tag{15} $$ where: - \\(K_k\\) is the gain from time step \\(k\\) ; - \\(z_k\\) is the actual measurement variable from time step \\(k\\) ; - \\(\\hat{x}\\_k\\) is the posteriori state from time step \\(k\\) ; - \\(P_k\\) is the posteriori estimate error covariance from time step \\(k\\) ;","title":"The discrete Kalman Filter Algorithm"},{"location":"m%26l/filter_kalman/#python-of-kalman-filter","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class KalmanFilter : def __init__ ( self , A , B , H , Q , R ): self . A = A self . B = B self . H = H self . Q = Q self . R = R self . U = np . zeros (( B . shape [ 1 ], 1 )) self . X = np . zeros (( A . shape [ 0 ], 1 )) self . X_pre = self . X self . P = np . zeros ( A . shape ) self . P_pre = self . P def __init__ ( self , A , H ): self . A = A self . X = np . zeros (( A . shape [ 0 ], 1 )) self . B = np . eye ( A . shape [ 0 ]) self . U = np . zeros (( self . B . shape [ 1 ], 1 )) self . Q = np . eye ( A . shape [ 0 ]) self . H = H self . R = np . eye ( H . shape [ 0 ]) self . X_pre = self . X self . P = np . zeros ( A . shape ) self . P_pre = self . P def filt ( self , Z ): \"\"\" x = A*x + B*u +Q y = H*x + R \"\"\" self . __predict () self . __update ( Z ) return self . X def __predict ( self ): \"\"\" x_next = A*x + B*u P_next = A*P*AT + Q \"\"\" self . X_pre = np . dot ( self . A , self . X ) + np . dot ( self . B , self . U ) self . P_pre = np . dot ( np . dot ( self . A , self . P ), self . A . T ) + self . Q def __update ( self , Z ): \"\"\" K = (P_next*HT) * (H*P_next*HT + R).inverse() x = x_next + K*(z - H*x_next) P = P_next - K*H*P_next \"\"\" K = np . dot ( np . dot ( self . P_pre , self . H . T ), np . linalg . inv ( np . dot ( np . dot ( self . H , self . P_pre ), self . H . T ) + self . R )) self . X = self . X_pre + np . dot ( K , Z - np . dot ( self . H , self . X_pre )) self . P = self . P_pre - np . dot ( np . dot ( K , self . H ), self . P_pre )","title":"Python of Kalman Filter"},{"location":"m%26l/imu_preintegration/","text":"The measurements of angular volocity and acceleration from an IMU are defined using Eqs below \\[ \\hat{w}_t = w_t + b^w_t + n^w_t \\tag 1 $$ $$ \\hat{a}_t = R^{BW}_t + b^a_t + n^a_t \\tag 2 \\] state \u89d2\u901f\u5ea6 \u52a0\u901f\u5ea6 \u539f\u59cb\u503c \\(\\hat{w}_t\\) \\(\\hat{a}_t\\) \u504f\u7f6e \\(bias^w_t\\) \\(bias^a_t\\) corrected \\(w^c_t=\\hat{w}_t - bias^w_t\\) \\(a^c_t=\\hat{a}_t - bias^a_t\\) update bias \\(bias^w_t = bias^w_{t-1}\\) \\(bias^a_t = bias^a_{t-1}\\) update pose \\(tf_{imu} = \\mathcal{R}^{\\frac{w^c_t + w^c_{t-1}}{2}\\cdot \\Delta t}\\) \\(R_t = R_{t-1}\\cdot tf_{imu}\\) ENU\u7cfb\u4e0b \\(dv=R \\cdot a^c_t + g\\) as for g,(\u4e0eimu-z\u8f74\u671d\u5411\u65e0\u5173,\u59cb\u7ec8\u4e3a \\(dv=R \\cdot a^c_t - 9.8\\) ) \u52a0\u901f\u5ea6: \\(\\mathcal{dv}=\\frac{R_t \\cdot a^c_t + R_{t-1} \\cdot a^c_{t-1}}{2} + g\\) \u901f\u5ea6: \\(v_t = v_{t-1} + dv \\cdot \\Delta t\\) \u4f4d\u7f6e: \\(P_t = P_{t-1} + \\frac{v_t + v_{t-1}}{2} \\cdot \\Delta t\\) code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 last_state //update biase Eigen :: Vector3d acc_bias = last_state -> acc_bias ; Eigen :: Vector3d gyro_bias = last_state -> gyro_bias ; Eigen :: Vector3d mean_corrected_angle_vel = ( corrected_angle_vel + last_state -> corrected_angle_vel ) / 2 ; double rot_angle = mean_corrected_angle_vel . norm () * dt ; Eigen :: Vector3d rot_axis ( 0 , 0 , 1 ); if ( rot_angle > 1e-9 ){ rot_axis = mean_corrected_angle_vel . normalized (); } Eigen :: AngleAxisd tf_rot_vector ( rot_angle , rot_axis ); attitude = ( last_state -> atitude * tf_rot_vector ). normalized (); //update pose attitude\u7c7b\u578b\u4e3aEigen::Quaterniond //\u56e0\u4e3aimu\u7684\u7ebf\u52a0\u901f\u5ea6\u548c\u89d2\u901f\u5ea6\u6570\u636e\u662f\u5728Body\u5750\u6807\u7cfb\u4e0b\u8868\u793a\u7684 //\u4e1c\u5317\u5929\u5750\u6807\u7cfb\u4e0b\u7ebf\u52a0\u901f\u5ea6\u8ba1\u7b97\u516c\u5f0f:\"a = R*(acc-acc_biase) + g\" //(acc_biase\u548cgyro_biase\u4e0d\u53ef\u6c42\uff0c\u6545\u901a\u5e38\u662f0\uff0cimu-z\u8f74\u671d\u4e0b/g=9.8, imu-z\u8f74\u671d\u4e0a/g=-9.8),\u73b0\u6709\u8f66\u4e0aimu-Z\u8f74\u671d\u4e0a //\u6240\u4ee5\u8981\u5229\u7528\u5bf9\u5e94\u65f6\u523b\u7684\u59ff\u6001\u5c06\u5176\u8f6c\u6362\u5230\u4e16\u754c\u5750\u6807\u7cfb\u4e0b\uff0c\u8f6c\u6362\u4e4b\u524d\u8981\u51cf\u53bbbias\uff0c\u8f6c\u5316\u4e4b\u540e\u8981\u51cf\u53bb\u91cd\u529b\u52a0\u901f\u5ea6 Eigen :: Vector3d gravity_vector ( 0 , 0 , -9.8 ); //imu-z up Eigen :: Vector3d dv = ( attitude * corrected_acc + last_state -> attitude * last_state -> corrected_acc ) / 2.0 + gravity_vector ; //\u52a0\u901f\u5ea6 //update velocity velocity = last_state -> velocity + dv * dt ; //update position: vt=vo+at, dv\u662f\u52a0\u901f\u5ea6 position = last_state -> position + ( velocity + last_state -> velocity ) / 2.0 * dt ;","title":"Integration IMU"},{"location":"m%26l/lidar-ethicp/","text":"\\[ y = \\frac{a}{b} \\] ETH-libpointmatcher\u4f7f\u7528 \u00b6 \u4f7f\u7528\u7684eigen\u7248\u672c\u9700\u548cpcl\u7684\u4e00\u81f4\uff0c \u79d1\u5b66\u5b9e\u9a8c\u65b9\u6cd5\u7684\u4e09\u4e2a\u539f\u5219: \u53ef\u6bd4\u8f83(\u53ef\u8bc4\u4f30)\u3001\u53ef\u590d\u73b0(\u7a33\u5b9a\u91cd\u590d)\u3001\u53ef\u8bc1\u660e(\u53ef\u89e3\u91ca) \u7b97\u6cd5\u5185\u5728\uff1a\u4ec0\u4e48\u53c2\u6570\u3001\u4e0d\u540c\u53c2\u6570\u4e0b\u8868\u73b0\u7684\u5dee\u5f02 \u7b97\u6cd5\u5916\u5728\uff1a\u51c6\u786e\u5ea6\u3001\u7cbe\u5ea6 The first one is to remove some points that do not bring any valuable infor- mation for the registration. As the complexity of the algorithm is linear in the number of points, reducing this number can have a significant impact on the time of registration. The second use of filters can be to add information to the point. The typical example is the inference of local structural properties of the shape, such as normal information or curvature. This information, which is usually not present in the raw sensor data, can allow for better registration through a more precise association of the points, or the computation of the error to minimize \\[ \\hat{T^B_A}=arg\\min_{T}(error(T(P^A),Q^B)) \\] different platform parameters Arto(rough Terrain outdoor robot) DataFilter ICP of ETH \u00b6 Dependency \u00b6 eigen:matrix and liear-albebra library libnabo:from eth, a fast k nearest neighbour library for low-dimensional spaces libboost Data flow of ETH-ICP \u00b6 Theory of eth-icp algorithm \u00b6 1. Reading and Reference Sources shapes P are point clouds and can be written in a matrix form with each column a point vector: $$ \\mathcal P = \\bold P=[p_1\\quad p_2\\quad ...\\quad p_N] $$ where \\(p_i\\) is a point and N the number of points in the point cloud Features is an Eigen matrix typically containing the coordinates of the points which form the cloud. Each column corresponds to a point in the cloud. The rows correspond to the dimensions of the points in homogeneous coordinates. Homogeneous coordinates are used to allow for translations and rotations. For 2D point clouds, there will thus be 3 rows and for 4 rows for 3D point clouds. Transformation Functions In case of a rigid transformation, if points are represented using homogeneous coordinates, a transformation T can be represented as a matrix T such that: $$ \\mathcal T(\\mathcal P) = \\boldsymbol{TP} = [\\boldsymbol{T}\\boldsymbol{p_1}\\quad \\boldsymbol{T}\\boldsymbol{p_2}\\quad ...\\quad \\boldsymbol{T}\\boldsymbol{p_N}] $$ \\(\\boldsymbol{T}\\) is then of the form: $$ \\boldsymbol{T} = \\begin{bmatrix}\\boldsymbol{R} & \\boldsymbol{t} \\ \\boldsymbol{0^T} & 1 \\end{bmatrix} $$ where \\(\\boldsymbol{R}\\) is a rotation matrix and \\(\\boldsymbol{t}\\) is a translation vector The generic formula computiing the final transform Equation becomes a simple matrix product: $$ \\begin{aligned} \\hat{\\mathcal{T}} {\\mathbb{A}}^{\\mathbb{B}} = ({\\mathop{\\bigcirc}\\limits { \\mathcal{T} {i-1}^i)\\circ\\mathcal{T {init}} \\ \\Leftrightarrow \\hat{\\boldsymbol{T {\\mathbb{A}}^{\\mathbb{B}}=\\left(\\mathop{\\prod}\\limits_{i}\\boldsymbol{T} {i ^i\\right)\\boldsymbol{T} {init} \\end{aligned} $$ $$ \\hat{T B_A}=arg\\min_{T}(error(T(P A),Q^B)) $$ Data Filters Feature Enhancement Descriptor Enhancement Feature Reduction features are sparse but not uniformly distributed. Nevertheless, the fact that sensors can provide a huge number of readings on a short period of time reates a bottleneck in term of computation power for the association as explained later Sensor Noise example1: random subsampling in order to decimate the point cloud: $$ \\mathcal{P}^{\\acute{}} = datafilter(\\mathcal{P}) = {\\boldsymbol{p}\\in\\mathcal{P}:\\eta(\\boldsymbol{p}) < \\theta} $$ where \\(\\eta\\in[0,1)\\) is a uniform-distributed random value and \u03b8 \u2208 [0, 1] a fixed threshold, corresponding to the fraction of points to keep example2: the computation of normal vectors in a point cloud: $$ \\mathcal{P}^{\\acute{}} = datafilter(\\mathcal{P}) = {\\boldsymbol{p}\\in\\mathcal{P}:\\eta(\\boldsymbol{p}) < \\theta} $$ datafilter example: Surface Normal Filter The surface normal to each point is estimated by finding a number of neighboring points and taking the eigen-vector corresponding to the smallest eigen-value of all neighboring points. Required descriptors: none Output descriptor: normals densities eigValues eigVectors Maximum Density Filter This filter is used to homogenize the density of a point cloud by rejecting a sub-sample of points in high-density regions.Points are only considered for rejection if they exceed a density threshold, otherwise they are preserved. Required descriptors: densities Output descriptor: none Experiment \u00b6 Test Platform :offline test and online(ranger) test Test Data :24/06/2020 dataset for mapping from hengtong Test Algorithm :eth-icp and pcl-icp Test Result : offline test \u00b6 comparison of the post poses and lidar-odometry by eth-icp comparison of the post poses and lidar-odometry by icp-pcl online test \u00b6 comparison of the post poses and lidar-odometry by eth-icp comparison of the post poses and lidar-odometry by icp-pcl","title":"icp\u7b97\u6cd5\u768420\u5e74"},{"location":"m%26l/lidar-ethicp/#eth-libpointmatcher","text":"\u4f7f\u7528\u7684eigen\u7248\u672c\u9700\u548cpcl\u7684\u4e00\u81f4\uff0c \u79d1\u5b66\u5b9e\u9a8c\u65b9\u6cd5\u7684\u4e09\u4e2a\u539f\u5219: \u53ef\u6bd4\u8f83(\u53ef\u8bc4\u4f30)\u3001\u53ef\u590d\u73b0(\u7a33\u5b9a\u91cd\u590d)\u3001\u53ef\u8bc1\u660e(\u53ef\u89e3\u91ca) \u7b97\u6cd5\u5185\u5728\uff1a\u4ec0\u4e48\u53c2\u6570\u3001\u4e0d\u540c\u53c2\u6570\u4e0b\u8868\u73b0\u7684\u5dee\u5f02 \u7b97\u6cd5\u5916\u5728\uff1a\u51c6\u786e\u5ea6\u3001\u7cbe\u5ea6 The first one is to remove some points that do not bring any valuable infor- mation for the registration. As the complexity of the algorithm is linear in the number of points, reducing this number can have a significant impact on the time of registration. The second use of filters can be to add information to the point. The typical example is the inference of local structural properties of the shape, such as normal information or curvature. This information, which is usually not present in the raw sensor data, can allow for better registration through a more precise association of the points, or the computation of the error to minimize \\[ \\hat{T^B_A}=arg\\min_{T}(error(T(P^A),Q^B)) \\] different platform parameters Arto(rough Terrain outdoor robot) DataFilter","title":"ETH-libpointmatcher\u4f7f\u7528"},{"location":"m%26l/lidar-ethicp/#icp-of-eth","text":"","title":"ICP of ETH"},{"location":"m%26l/lidar-ethicp/#dependency","text":"eigen:matrix and liear-albebra library libnabo:from eth, a fast k nearest neighbour library for low-dimensional spaces libboost","title":"Dependency"},{"location":"m%26l/lidar-ethicp/#data-flow-of-eth-icp","text":"","title":"Data flow of ETH-ICP "},{"location":"m%26l/lidar-ethicp/#theory-of-eth-icp-algorithm","text":"1. Reading and Reference Sources shapes P are point clouds and can be written in a matrix form with each column a point vector: $$ \\mathcal P = \\bold P=[p_1\\quad p_2\\quad ...\\quad p_N] $$ where \\(p_i\\) is a point and N the number of points in the point cloud Features is an Eigen matrix typically containing the coordinates of the points which form the cloud. Each column corresponds to a point in the cloud. The rows correspond to the dimensions of the points in homogeneous coordinates. Homogeneous coordinates are used to allow for translations and rotations. For 2D point clouds, there will thus be 3 rows and for 4 rows for 3D point clouds. Transformation Functions In case of a rigid transformation, if points are represented using homogeneous coordinates, a transformation T can be represented as a matrix T such that: $$ \\mathcal T(\\mathcal P) = \\boldsymbol{TP} = [\\boldsymbol{T}\\boldsymbol{p_1}\\quad \\boldsymbol{T}\\boldsymbol{p_2}\\quad ...\\quad \\boldsymbol{T}\\boldsymbol{p_N}] $$ \\(\\boldsymbol{T}\\) is then of the form: $$ \\boldsymbol{T} = \\begin{bmatrix}\\boldsymbol{R} & \\boldsymbol{t} \\ \\boldsymbol{0^T} & 1 \\end{bmatrix} $$ where \\(\\boldsymbol{R}\\) is a rotation matrix and \\(\\boldsymbol{t}\\) is a translation vector The generic formula computiing the final transform Equation becomes a simple matrix product: $$ \\begin{aligned} \\hat{\\mathcal{T}} {\\mathbb{A}}^{\\mathbb{B}} = ({\\mathop{\\bigcirc}\\limits { \\mathcal{T} {i-1}^i)\\circ\\mathcal{T {init}} \\ \\Leftrightarrow \\hat{\\boldsymbol{T {\\mathbb{A}}^{\\mathbb{B}}=\\left(\\mathop{\\prod}\\limits_{i}\\boldsymbol{T} {i ^i\\right)\\boldsymbol{T} {init} \\end{aligned} $$ $$ \\hat{T B_A}=arg\\min_{T}(error(T(P A),Q^B)) $$ Data Filters Feature Enhancement Descriptor Enhancement Feature Reduction features are sparse but not uniformly distributed. Nevertheless, the fact that sensors can provide a huge number of readings on a short period of time reates a bottleneck in term of computation power for the association as explained later Sensor Noise example1: random subsampling in order to decimate the point cloud: $$ \\mathcal{P}^{\\acute{}} = datafilter(\\mathcal{P}) = {\\boldsymbol{p}\\in\\mathcal{P}:\\eta(\\boldsymbol{p}) < \\theta} $$ where \\(\\eta\\in[0,1)\\) is a uniform-distributed random value and \u03b8 \u2208 [0, 1] a fixed threshold, corresponding to the fraction of points to keep example2: the computation of normal vectors in a point cloud: $$ \\mathcal{P}^{\\acute{}} = datafilter(\\mathcal{P}) = {\\boldsymbol{p}\\in\\mathcal{P}:\\eta(\\boldsymbol{p}) < \\theta} $$ datafilter example: Surface Normal Filter The surface normal to each point is estimated by finding a number of neighboring points and taking the eigen-vector corresponding to the smallest eigen-value of all neighboring points. Required descriptors: none Output descriptor: normals densities eigValues eigVectors Maximum Density Filter This filter is used to homogenize the density of a point cloud by rejecting a sub-sample of points in high-density regions.Points are only considered for rejection if they exceed a density threshold, otherwise they are preserved. Required descriptors: densities Output descriptor: none","title":"Theory of eth-icp algorithm"},{"location":"m%26l/lidar-ethicp/#experiment","text":"Test Platform :offline test and online(ranger) test Test Data :24/06/2020 dataset for mapping from hengtong Test Algorithm :eth-icp and pcl-icp Test Result :","title":"Experiment"},{"location":"m%26l/lidar-ethicp/#offline-test","text":"comparison of the post poses and lidar-odometry by eth-icp comparison of the post poses and lidar-odometry by icp-pcl","title":"offline test"},{"location":"m%26l/lidar-ethicp/#online-test","text":"comparison of the post poses and lidar-odometry by eth-icp comparison of the post poses and lidar-odometry by icp-pcl","title":"online test"},{"location":"m%26l/optimizer_gtsam/","text":"note of gtsam by DongJing Theory \u00b6 SLAM as a Bayes Net \u00b6 \\[ \\begin{aligned} &\\mathbf{P}(\\mathbf{X,L,Z}) = P(x_0)\\prod_{i=1}^MP(x_i|x_{i-1},u_i)\\prod_{k=1}^KP(z_k|x_{ik},l_{jk}) \\\\\\\\\\\\\\\\ & x_i = f_i(x_{i-1},u_i)+w_i \\Leftrightarrow \\\\\\\\ & P(x_i|x_{i-1},u_i)\\propto exp-\\frac{1}{2}||f_i(x_{i-1},u_i)-x_i||^2\\Lambda_i \\\\\\\\ &z_k=h_k(x_{ik},l_{jk})+v_k \\Leftrightarrow \\\\\\\\ &P(z_k|x_{ik},l_{jk})\\propto exp-\\frac{1}{2}||h_k(x_{ik},l_{jk})-z_k||^2_{\\sum_k} \\end{aligned} \\] SLAM as a Factor Graph \u00b6 SLAM as a Non-linear Least Squares \u00b6 Optimization on Manifold/Lie Groups \u00b6 iSAM2 and Bayes Tree \u00b6 Programming \u00b6 First Cpp example \u00b6 Use Gtsam in Matlab \u00b6 Write your own factor \u00b6 Expression Automatic Differentiation(New in 4.0) \u00b6 Traits Optimize any type in GTSAM(New in 4.0) \u00b6 Use GTSAM in Python \u00b6 Applications \u00b6 Visual-lnertial Odometry \u00b6 Structure from Motion(SFM) \u00b6 Multi-Robot SLAM Coordinate Frame and Distrubuted Optimization \u00b6 Multi-View Stereo and Optical Flow \u00b6 Motion Planning \u00b6","title":"Introduction of Gtsam"},{"location":"m%26l/optimizer_gtsam/#theory","text":"","title":"Theory"},{"location":"m%26l/optimizer_gtsam/#slam-as-a-bayes-net","text":"\\[ \\begin{aligned} &\\mathbf{P}(\\mathbf{X,L,Z}) = P(x_0)\\prod_{i=1}^MP(x_i|x_{i-1},u_i)\\prod_{k=1}^KP(z_k|x_{ik},l_{jk}) \\\\\\\\\\\\\\\\ & x_i = f_i(x_{i-1},u_i)+w_i \\Leftrightarrow \\\\\\\\ & P(x_i|x_{i-1},u_i)\\propto exp-\\frac{1}{2}||f_i(x_{i-1},u_i)-x_i||^2\\Lambda_i \\\\\\\\ &z_k=h_k(x_{ik},l_{jk})+v_k \\Leftrightarrow \\\\\\\\ &P(z_k|x_{ik},l_{jk})\\propto exp-\\frac{1}{2}||h_k(x_{ik},l_{jk})-z_k||^2_{\\sum_k} \\end{aligned} \\]","title":"SLAM as a Bayes Net"},{"location":"m%26l/optimizer_gtsam/#slam-as-a-factor-graph","text":"","title":"SLAM as a Factor Graph"},{"location":"m%26l/optimizer_gtsam/#slam-as-a-non-linear-least-squares","text":"","title":"SLAM as a Non-linear Least Squares"},{"location":"m%26l/optimizer_gtsam/#optimization-on-manifoldlie-groups","text":"","title":"Optimization on Manifold/Lie Groups"},{"location":"m%26l/optimizer_gtsam/#isam2-and-bayes-tree","text":"","title":"iSAM2 and Bayes Tree"},{"location":"m%26l/optimizer_gtsam/#programming","text":"","title":"Programming"},{"location":"m%26l/optimizer_gtsam/#first-cpp-example","text":"","title":"First Cpp example"},{"location":"m%26l/optimizer_gtsam/#use-gtsam-in-matlab","text":"","title":"Use Gtsam in Matlab"},{"location":"m%26l/optimizer_gtsam/#write-your-own-factor","text":"","title":"Write your own factor"},{"location":"m%26l/optimizer_gtsam/#expression-automatic-differentiationnew-in-40","text":"","title":"Expression Automatic Differentiation(New in 4.0)"},{"location":"m%26l/optimizer_gtsam/#traits-optimize-any-type-in-gtsamnew-in-40","text":"","title":"Traits Optimize any type in GTSAM(New in 4.0)"},{"location":"m%26l/optimizer_gtsam/#use-gtsam-in-python","text":"","title":"Use GTSAM in Python"},{"location":"m%26l/optimizer_gtsam/#applications","text":"","title":"Applications"},{"location":"m%26l/optimizer_gtsam/#visual-lnertial-odometry","text":"","title":"Visual-lnertial Odometry"},{"location":"m%26l/optimizer_gtsam/#structure-from-motionsfm","text":"","title":"Structure from Motion(SFM)"},{"location":"m%26l/optimizer_gtsam/#multi-robot-slam-coordinate-frame-and-distrubuted-optimization","text":"","title":"Multi-Robot SLAM Coordinate Frame and Distrubuted Optimization"},{"location":"m%26l/optimizer_gtsam/#multi-view-stereo-and-optical-flow","text":"","title":"Multi-View Stereo and Optical Flow"},{"location":"m%26l/optimizer_gtsam/#motion-planning","text":"","title":"Motion Planning"},{"location":"m%26l/point_matcher/","text":"note of pointmatcher \u00b6 \u7b80\u8981ICP \u00b6 target(ref-scan|pre-scan)\u548csource(read-scan|cur-scan)\u53bb\u9664\u8d28\u5fc3 $$ R^ = argmin \\frac{1}{2} \\sum_{i=1}^{n} \\lVert q_t - R q_s\\rVert^2 \\\\ t^ = q_t - R q_s \\\\ W = \\sum \\left( q_t q_s^T\\right) = U \\Sigma V^T \\to R = UV^T \\qquad t = q_t - Rq_s $$ residuals\u53ef\u7531 point->point \u3001 point->line \u3001 point->plane PointMatcher \u00b6 ref \u548c reading \u53bb\u9664\u8d28\u5fc3 \u00b6 tf_refi_in_refmean reference\u539f\u70b9\u4e3aref \u7b97\u6cd5\u6d41\u7a0b T->init Identity Transform \u5bf9reading\u505a \\(T\\) \u53d8\u6362,\u5f62\u6210reading_reset \u5bf9reading_reset\u4e2d\u6bcf\u4e2a\u70b9\u5728reference\u4e2d\u5bfb\u627e\u6700\u90bb\u8fd1\u7684\u70b9,\u5e76\u4fdd\u5b58\u8ddd\u79bb\u548cindex details \u00b6 ref's Normal e.g \\(3 \\times 277\\) $$ \\begin{bmatrix} x_1 &x_2 &... &x_n \\\\ y_1 &y_2 &... &y_n \\\\ z_1 &z_2 &... &z_n \\end{bmatrix} $$ \\(reading \\times ref's normal\\) , which is \\(277 \\times 3 \\cdot 3 \\times 277\\) $$ tmp = \\begin{bmatrix} 0 &-1 & 0 \\\\ 1 &0 & 0 \\\\ 0 & 0 &0 \\end{bmatrix} \\times \\begin{bmatrix} x_1 &x_2 &x_3 &... \\\\ y_1 &y_2 &y_3 &... \\\\ z_1 &z_2 &z_3 &... \\end{bmatrix} \\to \\begin{bmatrix} -y_1 & -y_2 & -y_3 & ... \\\\ x_1 & x_2 & x_3 & ... \\\\ 0 & 0 & 0 & ... \\end{bmatrix}\\\\ $$ $$ ret = tmp^T \\times ref's normal \\quad is \\quad N \\times N, which = \\begin{bmatrix} -y1 & x1 & 0 \\\\ -y2 & x2 & 0 \\\\ -y3 & x3 & 0 \\\\ ... & ... &... \\end{bmatrix} \\times \\begin{bmatrix} nx_1 & nx_2 & ... \\\\ ny_1 & ny_2 & ... \\\\ nz_1 & nz_2 & ... \\end{bmatrix} = \\begin{bmatrix} -y_1nx_1 + x_1ny_1 & elem_{12} & .....\\\\ elem_{21} & -y_2nx_2 + x_2ny_2 & .....\\\\ .... & ...&-y_nnx_n + x_nny_n \\end{bmatrix} $$ \u53d6 \\(ret\\) \u7684\u5bf9\u89d2\u7ebf,\u5373\u4e3areading\u70b9\u4e91\u5230ref's normal\u7684\u8ddd\u79bb(\u70b9\u5230\u6cd5\u5411\u91cf\u7684\u8ddd\u79bb) \\(tmp2 = ret.diagonal.transpose = \\begin{bmatrix} d1 & d2 & d3 & ...& d_n \\end{bmatrix}\\) \\(A=WF \\cdot F^t \\to AX=b \\qquad (4, 4) \\times (4, 1) \\to (4, 1)\\) $$ A \\cdot x=\\begin{bmatrix} \\sum_{i=1}^n d_i\\cdot wd_i & & & \\\\ & \\sum_{i=1}^nwnx_i\\cdot nx_i & & \\\\ & & \\sum_{i=1}^nwny_i\\cdot ny_i & \\\\ & & & \\sum_{i=1}^nwnz_i\\cdot nz_i \\end{bmatrix} \\begin{bmatrix} yaw \\\\ X \\\\ Y \\\\ Z \\end{bmatrix} = b $$ $$ b = \\underbrace{ \\begin{bmatrix} & tmp2 \\cdot \\omega(\u6743\u91cd) \\\\ nx_1 & nx_2 & ...\\\\ ny_1 & ny_2 & ...\\\\ nz_1 & nz_2 & ... \\end{bmatrix} } {WF} \\times \\underbrace{ \\begin{bmatrix} \\Delta x_1 nx_1 + \\Delta y_1 ny_1 + \\Delta z_1 nz_1 \\\\ \\Delta x_2 nx_2 + \\Delta y_2 ny_2 + \\Delta z_2 nz_2 \\\\ ...\\\\ \\end{bmatrix} } = -\\underbrace{ \\begin{bmatrix} \\sum {i=1}^n d_i \\cdot (\\Delta x_i nx_i + \\Delta y_i ny_i + \\Delta z_i nz_i) \\\\ \\sum_{i=1}^n nx_i \\cdot (\\Delta x_i nx_i + \\Delta y_i ny_i + \\Delta z_i nz_i) \\\\ \\sum_{i=1}^n ny_i \\cdot (\\Delta x_i nx_i + \\Delta y_i ny_i + \\Delta z_i nz_i) \\\\ \\sum_{i=1}^n nz_i \\cdot (\\Delta x_i nx_i + \\Delta y_i ny_i + \\Delta z_i nz_i) \\end{bmatrix} }_{(4\\times1)} $$","title":"note of pointmatcher"},{"location":"m%26l/point_matcher/#note-of-pointmatcher","text":"","title":"note of pointmatcher"},{"location":"m%26l/point_matcher/#icp","text":"target(ref-scan|pre-scan)\u548csource(read-scan|cur-scan)\u53bb\u9664\u8d28\u5fc3 $$ R^ = argmin \\frac{1}{2} \\sum_{i=1}^{n} \\lVert q_t - R q_s\\rVert^2 \\\\ t^ = q_t - R q_s \\\\ W = \\sum \\left( q_t q_s^T\\right) = U \\Sigma V^T \\to R = UV^T \\qquad t = q_t - Rq_s $$ residuals\u53ef\u7531 point->point \u3001 point->line \u3001 point->plane","title":"\u7b80\u8981ICP"},{"location":"m%26l/point_matcher/#pointmatcher","text":"","title":"PointMatcher"},{"location":"m%26l/point_matcher/#ref-reading","text":"tf_refi_in_refmean reference\u539f\u70b9\u4e3aref \u7b97\u6cd5\u6d41\u7a0b T->init Identity Transform \u5bf9reading\u505a \\(T\\) \u53d8\u6362,\u5f62\u6210reading_reset \u5bf9reading_reset\u4e2d\u6bcf\u4e2a\u70b9\u5728reference\u4e2d\u5bfb\u627e\u6700\u90bb\u8fd1\u7684\u70b9,\u5e76\u4fdd\u5b58\u8ddd\u79bb\u548cindex","title":"ref \u548c reading \u53bb\u9664\u8d28\u5fc3"},{"location":"m%26l/point_matcher/#details","text":"ref's Normal e.g \\(3 \\times 277\\) $$ \\begin{bmatrix} x_1 &x_2 &... &x_n \\\\ y_1 &y_2 &... &y_n \\\\ z_1 &z_2 &... &z_n \\end{bmatrix} $$ \\(reading \\times ref's normal\\) , which is \\(277 \\times 3 \\cdot 3 \\times 277\\) $$ tmp = \\begin{bmatrix} 0 &-1 & 0 \\\\ 1 &0 & 0 \\\\ 0 & 0 &0 \\end{bmatrix} \\times \\begin{bmatrix} x_1 &x_2 &x_3 &... \\\\ y_1 &y_2 &y_3 &... \\\\ z_1 &z_2 &z_3 &... \\end{bmatrix} \\to \\begin{bmatrix} -y_1 & -y_2 & -y_3 & ... \\\\ x_1 & x_2 & x_3 & ... \\\\ 0 & 0 & 0 & ... \\end{bmatrix}\\\\ $$ $$ ret = tmp^T \\times ref's normal \\quad is \\quad N \\times N, which = \\begin{bmatrix} -y1 & x1 & 0 \\\\ -y2 & x2 & 0 \\\\ -y3 & x3 & 0 \\\\ ... & ... &... \\end{bmatrix} \\times \\begin{bmatrix} nx_1 & nx_2 & ... \\\\ ny_1 & ny_2 & ... \\\\ nz_1 & nz_2 & ... \\end{bmatrix} = \\begin{bmatrix} -y_1nx_1 + x_1ny_1 & elem_{12} & .....\\\\ elem_{21} & -y_2nx_2 + x_2ny_2 & .....\\\\ .... & ...&-y_nnx_n + x_nny_n \\end{bmatrix} $$ \u53d6 \\(ret\\) \u7684\u5bf9\u89d2\u7ebf,\u5373\u4e3areading\u70b9\u4e91\u5230ref's normal\u7684\u8ddd\u79bb(\u70b9\u5230\u6cd5\u5411\u91cf\u7684\u8ddd\u79bb) \\(tmp2 = ret.diagonal.transpose = \\begin{bmatrix} d1 & d2 & d3 & ...& d_n \\end{bmatrix}\\) \\(A=WF \\cdot F^t \\to AX=b \\qquad (4, 4) \\times (4, 1) \\to (4, 1)\\) $$ A \\cdot x=\\begin{bmatrix} \\sum_{i=1}^n d_i\\cdot wd_i & & & \\\\ & \\sum_{i=1}^nwnx_i\\cdot nx_i & & \\\\ & & \\sum_{i=1}^nwny_i\\cdot ny_i & \\\\ & & & \\sum_{i=1}^nwnz_i\\cdot nz_i \\end{bmatrix} \\begin{bmatrix} yaw \\\\ X \\\\ Y \\\\ Z \\end{bmatrix} = b $$ $$ b = \\underbrace{ \\begin{bmatrix} & tmp2 \\cdot \\omega(\u6743\u91cd) \\\\ nx_1 & nx_2 & ...\\\\ ny_1 & ny_2 & ...\\\\ nz_1 & nz_2 & ... \\end{bmatrix} } {WF} \\times \\underbrace{ \\begin{bmatrix} \\Delta x_1 nx_1 + \\Delta y_1 ny_1 + \\Delta z_1 nz_1 \\\\ \\Delta x_2 nx_2 + \\Delta y_2 ny_2 + \\Delta z_2 nz_2 \\\\ ...\\\\ \\end{bmatrix} } = -\\underbrace{ \\begin{bmatrix} \\sum {i=1}^n d_i \\cdot (\\Delta x_i nx_i + \\Delta y_i ny_i + \\Delta z_i nz_i) \\\\ \\sum_{i=1}^n nx_i \\cdot (\\Delta x_i nx_i + \\Delta y_i ny_i + \\Delta z_i nz_i) \\\\ \\sum_{i=1}^n ny_i \\cdot (\\Delta x_i nx_i + \\Delta y_i ny_i + \\Delta z_i nz_i) \\\\ \\sum_{i=1}^n nz_i \\cdot (\\Delta x_i nx_i + \\Delta y_i ny_i + \\Delta z_i nz_i) \\end{bmatrix} }_{(4\\times1)} $$","title":"details"},{"location":"m%26l/slam_basic/","text":"\u4e09\u7ef4\u521a\u4f53\u8fd0\u52a8 \u00b6 \u56db\u5143\u6570\u7684\u5171\u8f6dconjugate \u5373\u4e3a\u5176\u81ea\u8eab\u7684\u9006 $$ T = \\begin{bmatrix} R & t \\\\ 0^T & 1 \\end{bmatrix} \\quad R^T = R^{-1} \\qquad \\rightarrow \\qquad T^{-1} = \\begin{bmatrix} R^T & -R^Tt \\\\ 0^T & 1 \\end{bmatrix} $$ \u53cd\u5bf9\u79f0\u77e9\u9635 \u00b6 \\[ \\begin{aligned} \\mathbf{\\overrightarrow{a}}\\times\\mathbf{\\overrightarrow{b}} &= \\begin{bmatrix} \\mathbf{i} & \\mathbf{j}& \\mathbf{k}\\\\\\\\ a_1 & a_2 &a_3\\\\\\\\ b_1 & b_2 &b_3 \\end{bmatrix} \\\\\\\\ &=\\begin{bmatrix} a_2b_3 - a_3b_2 \\\\\\\\ a_3b_1 - a_1b_3 \\\\\\\\ a_1b_2 - a_2b_1 \\end{bmatrix}\\\\\\\\ &= \\begin{bmatrix} 0 & -a_3 & a_2 \\\\\\\\ a_3 & 0 & -a_1 \\\\\\\\ -a_2 & a_1 & 0 \\end{bmatrix} .\\text{\u5373\u4e3aa\u7684\u53cd\u5bf9\u79f0\u77e9\u9635} \\\\\\\\ &=\\hat{\\mathbf{a}}\\mathbf{k} \\end{aligned} \\tag{4} \\] Camera \u00b6 \u50cf\u7d20\u5750\u6807 (u, v) \u548c\u76f8\u673a\u5750\u6807 (X, Y, Z) \u7684\u8f6c\u6362\u63a8\u5bfc $$ \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix} = \\frac{1}{Z} \\begin{bmatrix} f_x & 0 & cx \\\\ 0 & f_y & cy \\\\ 0 & 0 & 1 \\end{bmatrix} \\begin{bmatrix} X \\\\ Y \\\\ 1 \\end{bmatrix} = \\frac{1}{Z} \\cdot KP_c = \\frac{1}{Z} \\cdot KT P_w $$ K\u4e3a\u76f8\u673a\u5185\u53c2\u77e9\u9635\uff0c \\(T\\) \u4e3a\u8def\u6807\u70b9 \\(P_w\\) \u5bf9\u5e94\u7684\u5916\u53c2(\u7528\u4e8e\u5148\u5c06\u8def\u6807\u70b9\u7531\u4e16\u754c\u7cfb\u8f6c\u5230 \u76f8\u673a\u7cfb ,\u5373 \\(P_c = RP_w +t\\) ), \u5f52\u4e00\u5316\u76f8\u673a\u5750\u6807: \\(P_c = (\\frac{X}{Z}, \\frac{Y}{Z},1)\\) , \u50cf\u7d20\u5750\u6807: \\(P_{uv} = KP_c\\) $$ \\begin{cases} u = \\alpha X^\\prime +cx \\\\ v = \\beta Y^\\prime + cy \\quad cx\u548ccy\u7684\u57fa\u672c\u5355\u4f4d:pixel \\end{cases} \\rightarrow \\begin{cases} u = \\alpha \\cdot f \\cdot \\frac{X}{Z} + cx \\\\ v = \\beta \\cdot f \\cdot \\frac{Y}{Z} + cy \\quad \\alpha\u548c\\beta\u7684\u57fa\u672c\u5355\u4f4d:pixels/m \\end{cases} \\rightarrow \\begin{cases} u = f_x \\cdot \\frac{X}{Z} +cx \\\\ v = f_y \\cdot \\frac{Y}{Z} +cy \\end{cases} $$ - \u53cc\u76ee $$ Z = \\frac{fb}{d} \\qquad \u89c6\u5deed\u8d8a\u5c0f \\to Z\u8d8a\u5927,\u5373\u6d4b\u8ddd\u8d8a\u8fdc\uff0c\u540c\u7406\u57fa\u7ebfb\u8d8a\u5927\u4e5f\u662f\u5982\u6b64 $$ \u89c6\u89c9\u91cc\u7a0b\u8ba1 \u00b6 2D-2D\u5bf9\u6781\u51e0\u4f55(\u8ba1\u7b97\u6c42\u89e3: \u65cb\u8f6cR \u548c \u5e73\u79fbt) $$ x^T_2 \\hat{t} R x_1 = 0 \\qquad x_2\u548cx_1\u4e3a\u76f8\u673a\u5f52\u4e00\u5316\u5750\u6807 \u672c\u8d28\u77e9\u9635 E =\\hat{t} R \\\\ P^T_2 K^{-T} \\hat{t} R K^{-1} P_1 = 0 \\qquad \u57fa\u7840\u77e9\u9635 F = K^{-T} \\hat{t} R K^{-1} $$ \u672c\u8d28\u77e9\u9635 \\(E\\) \u5728\u4e0d\u540c\u5c3a\u5ea6\u4e0b\u7b49\u4ef7,\u56e0\u6b64\u4e0e\u5c3a\u5ea6\u65e0\u5173\u3002 \u7279\u5f81\u70b9\u5171\u9762\u6216\u76f8\u673a\u7eaf\u65cb\u8f6c\u65f6 \\(E\\) \u7684\u81ea\u7531\u5ea6\u4e0b\u964d,\u5373\u9000\u5316,\u56e0\u6b64\u4e00\u822c\u540c\u65f6\u4f30\u8ba1\u57fa\u7840\u77e9\u9635 \\(F\\) \u548c\u5355\u5e94\u6027\u77e9\u9635 \\(H\\) ,\u9009\u53d6\u91cd\u6295\u5f71\u8bef\u5dee\u6bd4\u8f83\u5c0f\u7684\u4f5c\u4e3a\u6700\u7ec8\u7684\u8fd0\u52a8\u4f30\u8ba1\u77e9\u9635\u3002 \u5355\u76eeslam\u521d\u59cb\u5316[\u65cb\u8f6c+\u5e73\u79fb]: \u76842\u4e2aimage must \u6709\u4e00\u5b9a\u7684\u5e73\u79fb\u91cf,\u800c\u540e\u7684\u8f68\u8ff9\u548c\u5730\u56fe\u90fd\u4ee5\u6b64\u4e3a\u5355\u4f4d \u4e09\u89d2\u5316\u6d4b\u91cf(\u8ba1\u7b97\u6c42\u89e3: \u8def\u6807\u70b9\u5373\u5730\u56fe\u70b9\u7684\u7a7a\u95f4\u4f4d\u7f6e) $$ s_1 x_1 = s_2 R x_2 + t $$ \u975e\u7ebf\u6027\u6700\u5c0f\u4e8c\u4e58 \u00b6 \u72b6\u6001\u4f30\u8ba1 \u00b6 \u673a\u5668\u4eba\u72b6\u6001\u4f30\u8ba1\u4e2d\u5df2\u77e5\u8f93\u5165\u6570\u636e \\(\\mathcal{u}\\) \u548c\u89c2\u6d4b\u6570\u636e \\(\\mathcal{x}\\) \u7684\u6761\u4ef6\u4e0b, \u672a\u77e5\u72b6\u6001 \\(x\\) \u7684\u6761\u4ef6\u6982\u7387\u5206\u5e03\u4e3a: \\(P(x|z,u)\\) , \u5f53\u6ca1\u6709\u6d4b\u91cf\u8fd0\u52a8\u7684\u4f20\u611f\u5668\u65f6\u76f8\u5f53\u4e8e\u4f30\u8ba1 \\(P(x|z)\\) \u7684\u6761\u4ef6\u6982\u7387\u5206\u5e03(\u82e5\u5ffd\u7565\u65f6\u5e8f\u5173\u7cfb\u5219\u53ef\u7406\u89e3\u4e3a\u4e00\u4e2aSFM\u95ee\u9898) \u6c42\u6700\u5927\u540e\u9a8c \\(\\simeq\\) \u6c42\u6700\u5927\u4f3c\u7136\u4f30\u8ba1 \\(\\to\\) \u6700\u5c0f\u5316\u8d1f\u5bf9\u6570(\u6700\u5c0f\u4e8c\u4e58\u95ee\u9898) - \u5229\u7528\u8d1d\u53f6\u65af\u6cd5\u5219 $$ P(x|z) = \\frac{P(z|x)P(x)}{P(z)} \\propto P(z|x)P(x) $$ $$ \u540e\u9a8cP(x|z) * \u5e38\u6570(evidence)P(z)= \u4f3c\u7136(likelihood)P(z|x) * \u5148\u9a8cP(x) $$ - \u6700\u5927\u5316\u540e\u9a8c\u6982\u7387(Maximize a Posterior,MAP): $$ x^ _{MAP} = argmax P(x|z) = argmax P(z|x)P(x) $$ - \u4e00\u822c\u8fd8\u4e0d\u77e5\u9053\u673a\u5668\u4eba\u5927\u6982\u7684\u4f4d\u7f6e\uff0c\u6b64\u65f6\u6ca1\u6709\u4e86 \u5148\u9a8c \u6240\u4ee5\u6c42 \u6700\u5927\u5316\u540e\u9a8c\u6982\u7387 \u76f8\u5f53\u4e8e\u6c42 \\(x\\) \u7684 \u6700\u5927\u4f3c\u7136\u4f30\u8ba1 (Maximize Likelihood Estimation,MLE) \u4f3c\u7136:\u5728\u73b0\u5728\u7684\u59ff\u6001\u4e0b\uff0c\u53ef\u80fd\u4ea7\u751f\u4ec0\u4e48\u6837\u7684\u89c2\u6d4b\u6570\u636e \u6700\u5927\u4f3c\u7136\u4f30\u8ba1:\u4ec0\u4e48\u6837\u7684\u72b6\u6001\u4e0b\uff0c\u6700\u53ef\u80fd\u4ea7\u751f\u5f53\u524d\u7684\u89c2\u6d4b\u6570\u636e ---->\u7b49\u540c\u4e8e\u6c42\u6700\u5927\u540e\u9a8c $$ x^ _{MLE} = argmax P(z|x) $$ - \u5bf9\u4e8e\u89c2\u6d4b\u6a21\u578b \\(z_{k,j} = h(y_j, x_k) + v_{k,j}\\) , \u4f3c\u7136 \\(P(z|x) = N(h(y_j, x_k),Q_{k,j})\\) \u670d\u4ece\u9ad8\u65af\u5206\u5e03, - \u4e3a\u6700\u5927\u5316\u4f3c \\(x_k, y_j\\) , \u7136\u901a\u5e38\u4f7f\u7528 \u6700\u5c0f\u5316\u8d1f\u5bf9\u6570 \u6765\u6c42\u4e00\u4e2a\u9ad8\u65af\u5206\u5e03\u7684\u6700\u5927\u4f3c\u7136 \u4e00\u822c\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u4efb\u610f\u7684\u9ad8\u65af\u5206\u5e03 \\(x \\sim N(\\mu, \\Sigma)\\) , \u5176\u6982\u7387\u5bc6\u5ea6\u51fd\u6570 \\(P(x) = \\frac{1}{\\sqrt{(2\\pi)^N det(\\Sigma)}}exp\\left(-\\frac{1}{2}(x - \\mu)^T \\Sigma^{-1} (x - \\mu)\\right)\\) \u53d6\u5176\u8d1f\u5bf9\u6570\u4e3a: \\(-ln(P(x)) = \\frac{1}{2}ln\\left((2\\pi)^N det(\\Sigma)\\right) + \\frac{1}{2}(x - \\mu)^T \\Sigma^{-1} (x - \\mu)\\) - \u8d1f\u5bf9\u6570\u5f0f \u7684\u7b2c\u4e00\u9879\u4e0e \\(x\\) \u65e0\u5173\uff0c\u76f4\u63a5\u7565\u53bb, \u5219\u6c42\u72b6\u6001\u7684\u6700\u5927\u4f3c\u7136\u4f30\u8ba1\u2192\u6700\u5c0f\u5316\u53f3\u4fa7\u7684\u4e8c\u6b21\u578b\u9879\uff0c\u4ee3\u5165SLAM\u89c2\u6d4b\u6a21\u578b\uff0c\u7b49\u540c\u4e8e\u6c42 \\(x^* = argmin \\left((z_{k,j} - h(x_k, y_i))^T Q^{-1}_{k,j} (z_{k,j} - h(x_k, y_i)) \\right)\\) \u7b49\u4ef7\u4e8e\u6c42\u566a\u58f0\u9879(\u5373\u8bef\u5dee)\u7684\u6700\u5c0f\u4e8c\u4e58 \u6700\u5c0f\u4e8c\u4e58\u95ee\u9898 \u00b6 $$ \\min\\limits_{x}\\frac{1}{2}|f(x)|^2 $$ \u672a\u77e5\u81ea\u53d8\u91cf \\(x \\isin \\mathbb{R}^n\\) , \\(f\\) \u4e3a\u4e00\u4e2a\u4efb\u610f\u7684\u975e\u7ebf\u6027\u51fd\u6570,\u5047\u8bbe\u4e3a \\(m\\) \u7ef4: \\(f(x) \\isin \\mathbb{R}^m\\) \u3002 - \u89e3\u6790\u5f62\u5f0f\u6c42\u89e3: \u4ee4\u76ee\u6807\u51fd\u6570\u5bfc\u6570\u4e3a\u96f6 \\(\\frac{df}{d \\mathbf{x}}=\\mathbf{0}\\) ,\u7136\u540e\u6c42\u89e3 \\(\\mathbf{x}\\) \u7684\u6700\u4f18\u89e3 - \u4f18\u5316\u6c42\u89e3:SLAM\u4e2d\u7684\u6700\u5c0f\u4e8c\u4e58\u95ee\u9898\u5bfc\u6570\u5f62\u5f0f\u6bd4\u8f83\u590d\u6742\uff0c\u4f7f\u7528\u8fed\u4ee3\u7684\u65b9\u5f0f\u4ece\u4e00\u4e2a\u521d\u59cb\u503c\u51fa\u53d1\uff0c\u901a\u8fc7\u4e0d\u65ad\u8fed\u4ee3\u66f4\u65b0\u5f53\u524d\u7684\u4f18\u5316\u53d8\u91cf\u4f7f\u76ee\u6807\u51fd\u6570\u4e0b\u964d 1. \u7ed9\u5b9a\u67d0\u4e2a\u521d\u59cb\u503c \\(\\mathbf{x}_0\\) 2. \u5bf9\u4e8e\u7b2c \\(\\mathcal{k}\\) \u6b21\u8fed\u4ee3\uff0c\u5bfb\u627e\u4e00\u4e2a\u589e\u91cf \\(\\Delta x_k\\) \uff0c\u4f7f\u5f97 \\(|f(x_k + \\Delta x_k)|^2\\) \u8fbe\u5230\u6781\u5c0f\u503c 3. \u82e5 \\(\\Delta x_k\\) \u8db3\u591f\u5c0f\uff0c\u5219\u505c\u6b62\u8fed\u4ee3 4. \u5426\u5219\uff0c\u4ee4 \\(x_{k+1} = x_k + \\Delta x_k\\) - \u4e00\u9636\u548c\u4e8c\u9636\u68af\u5ea6\u6cd5 \u5c06\u76ee\u6807\u51fd\u6570\u5728 \\(x_k\\) \u9644\u8fd1\u6cf0\u52d2\u5c55\u5f00 $$ f(x + \\Delta)^2 = f(x)^2 + J(x)\\Delta x + \\frac{1}{2} \\Delta x^T \\mathbin{H} \\Delta x $$ \\(J\\) \u4e3a \\(f(x)^2\\) \u5173\u4e8e \\(x\\) \u7684\u5bfc\u6570(Jacobian\u77e9\u9635)\uff0c\u800c \\(H\\) \u4e3a\u4e8c\u9636\u5bfc\u6570(Hessian\u77e9\u9635)\uff0c\u4fdd\u7559\u6cf0\u52d2\u5c55\u5f00\u7684\u4e00\u9636\u6216\u4e8c\u9636\u9879\u5bf9\u5e94\u7684\u6c42\u89e3\u65b9\u6cd5\u5219\u4e3a\u4e00\u9636\u68af\u5ea6\u6216\u4e8c\u9636\u68af\u5ea6 - \u4fdd\u7559\u4e00\u9636\u68af\u5ea6\uff0c\u589e\u91cf\u65b9\u7a0b\u4e3a $$ \\Delta x^ = -J(x) $$ \u76f4\u89c2\u610f\u4e49\u7b80\u5355\uff0c\u6cbf\u53cd\u5411\u68af\u5ea6\u65b9\u5411\u524d\u8fdb\u5373\u53ef\uff0c\u901a\u5e38\u4f1a\u8ba1\u7b97\u8be5\u65b9\u5411\u4e0a\u7684\u4e00\u4e2a\u6b65\u957f \\(\\lambda\\) , \u4ee5\u83b7\u5f97\u6700\u5feb\u4e0b\u964d\u7684\u65b9\u5f0f---> \u6700\u901f\u4e0b\u964d\u6cd5 (\u8fc7\u4e8e\u8d2a\u5fc3,\u5bb9\u6613\u8d70\u952f\u9f7f\u8def\u7ebf\uff0c\u589e\u52a0\u8fed\u4ee3\u6b21\u6570) - \u4fdd\u7559\u4e8c\u9636\u68af\u5ea6\uff0c\u589e\u91cf\u65b9\u7a0b\u4e3a $$ \\Delta x^ = argminf(x)^2 +J(x) \\Delta x + \\frac{1}{2} \\Delta x^T \\mathbin{H} \\Delta x $$ \u8be5\u7b49\u5f0f\u4ee4\u5173\u4e8e \\(\\Delta x\\) \u7684\u5bfc\u6570\u4e3a\u96f6\uff0c\u5f97\u589e\u91cf\u65b9\u7a0b\u4e3a: $H \\Delta x = -J $ \u725b\u987f\u6cd5 (\u9700\u8ba1\u7b97 \\(H\\) \u77e9\u9635\uff0c\u4e00\u822c\u6bd4\u8f83\u56f0\u96be) - Gauss-Newton (\u6700\u4f18\u5316\u7b97\u6cd5\u6700\u7b80\u5355\u7684\u65b9\u6cd5\u4e4b\u4e00, \u5c06 \\(f(x)\\) \u8fdb\u884c\u4e00\u9636\u6cf0\u52d2\u5c55\u5f00\uff0c\u800c\u975e\u76ee\u6807\u51fd\u6570 \\(f(x)^2\\) ) $$ f(x + \\Delta x) \\approx f(x) + J(x)\\Delta x $$ \u8be5\u5f0f \\(J(x)\\) \u4e3a \\(f(x)\\) \u5173\u4e8e \\(x\\) \u7684\u5bfc\u6570\uff0c\u5f97\u7ebf\u6027\u6700\u5c0f\u4e8c\u4e58\u95ee\u9898\u4e3a: $$ \\Delta x^ k = arg\\min\\limits {\\Delta x}\\frac{1}{2} |f(x) + J(x)\\Delta x|^2 $$ \u5c06\u6700\u5c0f\u4e8c\u4e58\u95ee\u9898\u7684\u76ee\u6807\u51fd\u6570 \\(|f(x) + J(x)\\Delta x|^2\\) \u5bf9 \\(\\Delta x\\) \u6c42\u5bfc\u5e76\u4ee4\u5bfc\u6570\u4e3a\u96f6\u5f97 \u589e\u91cf\u65b9\u7a0b(\u9ad8\u65af\u725b\u987f\u65b9\u7a0bGaussNewtonEquations\u6216\u6b63\u89c4\u65b9\u7a0bNormalEquations) $$ J(x)^T J(x) \\Delta x = -J(x)f(x) \\sim H \\Delta x =g $$ Gauss-Newton\u5c06 \\(J^T J\\) \u4f5c\u4e3a\u725b\u987f\u6cd5\u4e2d\u4e8c\u9636 \\(Hessian\\) \u77e9\u9635\u7684\u8fd1\u4f3c\uff0c \u6c42\u89e3\u589e\u91cf\u65b9\u7a0b\u662f\u6574\u4e2a\u4f18\u5316\u95ee\u9898\u7684\u6838\u5fc3 * - Gauss-Newton\u7b97\u6cd5\u6b65\u9aa4 1. \u7ed9\u5b9a\u67d0\u4e2a\u521d\u59cb\u503c \\(x_0\\) 2. \u5bf9\u4e8e\u7b2c \\(\\mathcal{k}\\) \u6b21\u8fed\u4ee3\uff0c\u6c42\u51fa\u5f53\u524d\u7684Jacobian\u77e9\u9635 \\(J(x_k)\\) \u548c\u8bef\u5dee \\(f(x_k)\\) 3. \u6c42\u89e3\u589e\u91cf\u65b9\u7a0b: \\(H \\Delta x =g\\) 4. \u82e5 \\(\\Delta x_k\\) \u8db3\u591f\u5c0f\uff0c\u5219\u505c\u6b62\u3002\u5426\u5219\uff0c\u4ee4 \\(x_{k+1} = x_k + \\Delta x_k\\) ,\u7136\u540e\u8fd4\u56de\u6b65\u9aa42","title":"Slam basic"},{"location":"m%26l/slam_basic/#_1","text":"\u56db\u5143\u6570\u7684\u5171\u8f6dconjugate \u5373\u4e3a\u5176\u81ea\u8eab\u7684\u9006 $$ T = \\begin{bmatrix} R & t \\\\ 0^T & 1 \\end{bmatrix} \\quad R^T = R^{-1} \\qquad \\rightarrow \\qquad T^{-1} = \\begin{bmatrix} R^T & -R^Tt \\\\ 0^T & 1 \\end{bmatrix} $$","title":"\u4e09\u7ef4\u521a\u4f53\u8fd0\u52a8"},{"location":"m%26l/slam_basic/#_2","text":"\\[ \\begin{aligned} \\mathbf{\\overrightarrow{a}}\\times\\mathbf{\\overrightarrow{b}} &= \\begin{bmatrix} \\mathbf{i} & \\mathbf{j}& \\mathbf{k}\\\\\\\\ a_1 & a_2 &a_3\\\\\\\\ b_1 & b_2 &b_3 \\end{bmatrix} \\\\\\\\ &=\\begin{bmatrix} a_2b_3 - a_3b_2 \\\\\\\\ a_3b_1 - a_1b_3 \\\\\\\\ a_1b_2 - a_2b_1 \\end{bmatrix}\\\\\\\\ &= \\begin{bmatrix} 0 & -a_3 & a_2 \\\\\\\\ a_3 & 0 & -a_1 \\\\\\\\ -a_2 & a_1 & 0 \\end{bmatrix} .\\text{\u5373\u4e3aa\u7684\u53cd\u5bf9\u79f0\u77e9\u9635} \\\\\\\\ &=\\hat{\\mathbf{a}}\\mathbf{k} \\end{aligned} \\tag{4} \\]","title":"\u53cd\u5bf9\u79f0\u77e9\u9635"},{"location":"m%26l/slam_basic/#camera","text":"\u50cf\u7d20\u5750\u6807 (u, v) \u548c\u76f8\u673a\u5750\u6807 (X, Y, Z) \u7684\u8f6c\u6362\u63a8\u5bfc $$ \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix} = \\frac{1}{Z} \\begin{bmatrix} f_x & 0 & cx \\\\ 0 & f_y & cy \\\\ 0 & 0 & 1 \\end{bmatrix} \\begin{bmatrix} X \\\\ Y \\\\ 1 \\end{bmatrix} = \\frac{1}{Z} \\cdot KP_c = \\frac{1}{Z} \\cdot KT P_w $$ K\u4e3a\u76f8\u673a\u5185\u53c2\u77e9\u9635\uff0c \\(T\\) \u4e3a\u8def\u6807\u70b9 \\(P_w\\) \u5bf9\u5e94\u7684\u5916\u53c2(\u7528\u4e8e\u5148\u5c06\u8def\u6807\u70b9\u7531\u4e16\u754c\u7cfb\u8f6c\u5230 \u76f8\u673a\u7cfb ,\u5373 \\(P_c = RP_w +t\\) ), \u5f52\u4e00\u5316\u76f8\u673a\u5750\u6807: \\(P_c = (\\frac{X}{Z}, \\frac{Y}{Z},1)\\) , \u50cf\u7d20\u5750\u6807: \\(P_{uv} = KP_c\\) $$ \\begin{cases} u = \\alpha X^\\prime +cx \\\\ v = \\beta Y^\\prime + cy \\quad cx\u548ccy\u7684\u57fa\u672c\u5355\u4f4d:pixel \\end{cases} \\rightarrow \\begin{cases} u = \\alpha \\cdot f \\cdot \\frac{X}{Z} + cx \\\\ v = \\beta \\cdot f \\cdot \\frac{Y}{Z} + cy \\quad \\alpha\u548c\\beta\u7684\u57fa\u672c\u5355\u4f4d:pixels/m \\end{cases} \\rightarrow \\begin{cases} u = f_x \\cdot \\frac{X}{Z} +cx \\\\ v = f_y \\cdot \\frac{Y}{Z} +cy \\end{cases} $$ - \u53cc\u76ee $$ Z = \\frac{fb}{d} \\qquad \u89c6\u5deed\u8d8a\u5c0f \\to Z\u8d8a\u5927,\u5373\u6d4b\u8ddd\u8d8a\u8fdc\uff0c\u540c\u7406\u57fa\u7ebfb\u8d8a\u5927\u4e5f\u662f\u5982\u6b64 $$","title":"Camera"},{"location":"m%26l/slam_basic/#_3","text":"2D-2D\u5bf9\u6781\u51e0\u4f55(\u8ba1\u7b97\u6c42\u89e3: \u65cb\u8f6cR \u548c \u5e73\u79fbt) $$ x^T_2 \\hat{t} R x_1 = 0 \\qquad x_2\u548cx_1\u4e3a\u76f8\u673a\u5f52\u4e00\u5316\u5750\u6807 \u672c\u8d28\u77e9\u9635 E =\\hat{t} R \\\\ P^T_2 K^{-T} \\hat{t} R K^{-1} P_1 = 0 \\qquad \u57fa\u7840\u77e9\u9635 F = K^{-T} \\hat{t} R K^{-1} $$ \u672c\u8d28\u77e9\u9635 \\(E\\) \u5728\u4e0d\u540c\u5c3a\u5ea6\u4e0b\u7b49\u4ef7,\u56e0\u6b64\u4e0e\u5c3a\u5ea6\u65e0\u5173\u3002 \u7279\u5f81\u70b9\u5171\u9762\u6216\u76f8\u673a\u7eaf\u65cb\u8f6c\u65f6 \\(E\\) \u7684\u81ea\u7531\u5ea6\u4e0b\u964d,\u5373\u9000\u5316,\u56e0\u6b64\u4e00\u822c\u540c\u65f6\u4f30\u8ba1\u57fa\u7840\u77e9\u9635 \\(F\\) \u548c\u5355\u5e94\u6027\u77e9\u9635 \\(H\\) ,\u9009\u53d6\u91cd\u6295\u5f71\u8bef\u5dee\u6bd4\u8f83\u5c0f\u7684\u4f5c\u4e3a\u6700\u7ec8\u7684\u8fd0\u52a8\u4f30\u8ba1\u77e9\u9635\u3002 \u5355\u76eeslam\u521d\u59cb\u5316[\u65cb\u8f6c+\u5e73\u79fb]: \u76842\u4e2aimage must \u6709\u4e00\u5b9a\u7684\u5e73\u79fb\u91cf,\u800c\u540e\u7684\u8f68\u8ff9\u548c\u5730\u56fe\u90fd\u4ee5\u6b64\u4e3a\u5355\u4f4d \u4e09\u89d2\u5316\u6d4b\u91cf(\u8ba1\u7b97\u6c42\u89e3: \u8def\u6807\u70b9\u5373\u5730\u56fe\u70b9\u7684\u7a7a\u95f4\u4f4d\u7f6e) $$ s_1 x_1 = s_2 R x_2 + t $$","title":"\u89c6\u89c9\u91cc\u7a0b\u8ba1"},{"location":"m%26l/slam_basic/#_4","text":"","title":"\u975e\u7ebf\u6027\u6700\u5c0f\u4e8c\u4e58"},{"location":"m%26l/slam_basic/#_5","text":"\u673a\u5668\u4eba\u72b6\u6001\u4f30\u8ba1\u4e2d\u5df2\u77e5\u8f93\u5165\u6570\u636e \\(\\mathcal{u}\\) \u548c\u89c2\u6d4b\u6570\u636e \\(\\mathcal{x}\\) \u7684\u6761\u4ef6\u4e0b, \u672a\u77e5\u72b6\u6001 \\(x\\) \u7684\u6761\u4ef6\u6982\u7387\u5206\u5e03\u4e3a: \\(P(x|z,u)\\) , \u5f53\u6ca1\u6709\u6d4b\u91cf\u8fd0\u52a8\u7684\u4f20\u611f\u5668\u65f6\u76f8\u5f53\u4e8e\u4f30\u8ba1 \\(P(x|z)\\) \u7684\u6761\u4ef6\u6982\u7387\u5206\u5e03(\u82e5\u5ffd\u7565\u65f6\u5e8f\u5173\u7cfb\u5219\u53ef\u7406\u89e3\u4e3a\u4e00\u4e2aSFM\u95ee\u9898) \u6c42\u6700\u5927\u540e\u9a8c \\(\\simeq\\) \u6c42\u6700\u5927\u4f3c\u7136\u4f30\u8ba1 \\(\\to\\) \u6700\u5c0f\u5316\u8d1f\u5bf9\u6570(\u6700\u5c0f\u4e8c\u4e58\u95ee\u9898) - \u5229\u7528\u8d1d\u53f6\u65af\u6cd5\u5219 $$ P(x|z) = \\frac{P(z|x)P(x)}{P(z)} \\propto P(z|x)P(x) $$ $$ \u540e\u9a8cP(x|z) * \u5e38\u6570(evidence)P(z)= \u4f3c\u7136(likelihood)P(z|x) * \u5148\u9a8cP(x) $$ - \u6700\u5927\u5316\u540e\u9a8c\u6982\u7387(Maximize a Posterior,MAP): $$ x^ _{MAP} = argmax P(x|z) = argmax P(z|x)P(x) $$ - \u4e00\u822c\u8fd8\u4e0d\u77e5\u9053\u673a\u5668\u4eba\u5927\u6982\u7684\u4f4d\u7f6e\uff0c\u6b64\u65f6\u6ca1\u6709\u4e86 \u5148\u9a8c \u6240\u4ee5\u6c42 \u6700\u5927\u5316\u540e\u9a8c\u6982\u7387 \u76f8\u5f53\u4e8e\u6c42 \\(x\\) \u7684 \u6700\u5927\u4f3c\u7136\u4f30\u8ba1 (Maximize Likelihood Estimation,MLE) \u4f3c\u7136:\u5728\u73b0\u5728\u7684\u59ff\u6001\u4e0b\uff0c\u53ef\u80fd\u4ea7\u751f\u4ec0\u4e48\u6837\u7684\u89c2\u6d4b\u6570\u636e \u6700\u5927\u4f3c\u7136\u4f30\u8ba1:\u4ec0\u4e48\u6837\u7684\u72b6\u6001\u4e0b\uff0c\u6700\u53ef\u80fd\u4ea7\u751f\u5f53\u524d\u7684\u89c2\u6d4b\u6570\u636e ---->\u7b49\u540c\u4e8e\u6c42\u6700\u5927\u540e\u9a8c $$ x^ _{MLE} = argmax P(z|x) $$ - \u5bf9\u4e8e\u89c2\u6d4b\u6a21\u578b \\(z_{k,j} = h(y_j, x_k) + v_{k,j}\\) , \u4f3c\u7136 \\(P(z|x) = N(h(y_j, x_k),Q_{k,j})\\) \u670d\u4ece\u9ad8\u65af\u5206\u5e03, - \u4e3a\u6700\u5927\u5316\u4f3c \\(x_k, y_j\\) , \u7136\u901a\u5e38\u4f7f\u7528 \u6700\u5c0f\u5316\u8d1f\u5bf9\u6570 \u6765\u6c42\u4e00\u4e2a\u9ad8\u65af\u5206\u5e03\u7684\u6700\u5927\u4f3c\u7136 \u4e00\u822c\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u4efb\u610f\u7684\u9ad8\u65af\u5206\u5e03 \\(x \\sim N(\\mu, \\Sigma)\\) , \u5176\u6982\u7387\u5bc6\u5ea6\u51fd\u6570 \\(P(x) = \\frac{1}{\\sqrt{(2\\pi)^N det(\\Sigma)}}exp\\left(-\\frac{1}{2}(x - \\mu)^T \\Sigma^{-1} (x - \\mu)\\right)\\) \u53d6\u5176\u8d1f\u5bf9\u6570\u4e3a: \\(-ln(P(x)) = \\frac{1}{2}ln\\left((2\\pi)^N det(\\Sigma)\\right) + \\frac{1}{2}(x - \\mu)^T \\Sigma^{-1} (x - \\mu)\\) - \u8d1f\u5bf9\u6570\u5f0f \u7684\u7b2c\u4e00\u9879\u4e0e \\(x\\) \u65e0\u5173\uff0c\u76f4\u63a5\u7565\u53bb, \u5219\u6c42\u72b6\u6001\u7684\u6700\u5927\u4f3c\u7136\u4f30\u8ba1\u2192\u6700\u5c0f\u5316\u53f3\u4fa7\u7684\u4e8c\u6b21\u578b\u9879\uff0c\u4ee3\u5165SLAM\u89c2\u6d4b\u6a21\u578b\uff0c\u7b49\u540c\u4e8e\u6c42 \\(x^* = argmin \\left((z_{k,j} - h(x_k, y_i))^T Q^{-1}_{k,j} (z_{k,j} - h(x_k, y_i)) \\right)\\) \u7b49\u4ef7\u4e8e\u6c42\u566a\u58f0\u9879(\u5373\u8bef\u5dee)\u7684\u6700\u5c0f\u4e8c\u4e58","title":"\u72b6\u6001\u4f30\u8ba1"},{"location":"m%26l/slam_basic/#_6","text":"$$ \\min\\limits_{x}\\frac{1}{2}|f(x)|^2 $$ \u672a\u77e5\u81ea\u53d8\u91cf \\(x \\isin \\mathbb{R}^n\\) , \\(f\\) \u4e3a\u4e00\u4e2a\u4efb\u610f\u7684\u975e\u7ebf\u6027\u51fd\u6570,\u5047\u8bbe\u4e3a \\(m\\) \u7ef4: \\(f(x) \\isin \\mathbb{R}^m\\) \u3002 - \u89e3\u6790\u5f62\u5f0f\u6c42\u89e3: \u4ee4\u76ee\u6807\u51fd\u6570\u5bfc\u6570\u4e3a\u96f6 \\(\\frac{df}{d \\mathbf{x}}=\\mathbf{0}\\) ,\u7136\u540e\u6c42\u89e3 \\(\\mathbf{x}\\) \u7684\u6700\u4f18\u89e3 - \u4f18\u5316\u6c42\u89e3:SLAM\u4e2d\u7684\u6700\u5c0f\u4e8c\u4e58\u95ee\u9898\u5bfc\u6570\u5f62\u5f0f\u6bd4\u8f83\u590d\u6742\uff0c\u4f7f\u7528\u8fed\u4ee3\u7684\u65b9\u5f0f\u4ece\u4e00\u4e2a\u521d\u59cb\u503c\u51fa\u53d1\uff0c\u901a\u8fc7\u4e0d\u65ad\u8fed\u4ee3\u66f4\u65b0\u5f53\u524d\u7684\u4f18\u5316\u53d8\u91cf\u4f7f\u76ee\u6807\u51fd\u6570\u4e0b\u964d 1. \u7ed9\u5b9a\u67d0\u4e2a\u521d\u59cb\u503c \\(\\mathbf{x}_0\\) 2. \u5bf9\u4e8e\u7b2c \\(\\mathcal{k}\\) \u6b21\u8fed\u4ee3\uff0c\u5bfb\u627e\u4e00\u4e2a\u589e\u91cf \\(\\Delta x_k\\) \uff0c\u4f7f\u5f97 \\(|f(x_k + \\Delta x_k)|^2\\) \u8fbe\u5230\u6781\u5c0f\u503c 3. \u82e5 \\(\\Delta x_k\\) \u8db3\u591f\u5c0f\uff0c\u5219\u505c\u6b62\u8fed\u4ee3 4. \u5426\u5219\uff0c\u4ee4 \\(x_{k+1} = x_k + \\Delta x_k\\) - \u4e00\u9636\u548c\u4e8c\u9636\u68af\u5ea6\u6cd5 \u5c06\u76ee\u6807\u51fd\u6570\u5728 \\(x_k\\) \u9644\u8fd1\u6cf0\u52d2\u5c55\u5f00 $$ f(x + \\Delta)^2 = f(x)^2 + J(x)\\Delta x + \\frac{1}{2} \\Delta x^T \\mathbin{H} \\Delta x $$ \\(J\\) \u4e3a \\(f(x)^2\\) \u5173\u4e8e \\(x\\) \u7684\u5bfc\u6570(Jacobian\u77e9\u9635)\uff0c\u800c \\(H\\) \u4e3a\u4e8c\u9636\u5bfc\u6570(Hessian\u77e9\u9635)\uff0c\u4fdd\u7559\u6cf0\u52d2\u5c55\u5f00\u7684\u4e00\u9636\u6216\u4e8c\u9636\u9879\u5bf9\u5e94\u7684\u6c42\u89e3\u65b9\u6cd5\u5219\u4e3a\u4e00\u9636\u68af\u5ea6\u6216\u4e8c\u9636\u68af\u5ea6 - \u4fdd\u7559\u4e00\u9636\u68af\u5ea6\uff0c\u589e\u91cf\u65b9\u7a0b\u4e3a $$ \\Delta x^ = -J(x) $$ \u76f4\u89c2\u610f\u4e49\u7b80\u5355\uff0c\u6cbf\u53cd\u5411\u68af\u5ea6\u65b9\u5411\u524d\u8fdb\u5373\u53ef\uff0c\u901a\u5e38\u4f1a\u8ba1\u7b97\u8be5\u65b9\u5411\u4e0a\u7684\u4e00\u4e2a\u6b65\u957f \\(\\lambda\\) , \u4ee5\u83b7\u5f97\u6700\u5feb\u4e0b\u964d\u7684\u65b9\u5f0f---> \u6700\u901f\u4e0b\u964d\u6cd5 (\u8fc7\u4e8e\u8d2a\u5fc3,\u5bb9\u6613\u8d70\u952f\u9f7f\u8def\u7ebf\uff0c\u589e\u52a0\u8fed\u4ee3\u6b21\u6570) - \u4fdd\u7559\u4e8c\u9636\u68af\u5ea6\uff0c\u589e\u91cf\u65b9\u7a0b\u4e3a $$ \\Delta x^ = argminf(x)^2 +J(x) \\Delta x + \\frac{1}{2} \\Delta x^T \\mathbin{H} \\Delta x $$ \u8be5\u7b49\u5f0f\u4ee4\u5173\u4e8e \\(\\Delta x\\) \u7684\u5bfc\u6570\u4e3a\u96f6\uff0c\u5f97\u589e\u91cf\u65b9\u7a0b\u4e3a: $H \\Delta x = -J $ \u725b\u987f\u6cd5 (\u9700\u8ba1\u7b97 \\(H\\) \u77e9\u9635\uff0c\u4e00\u822c\u6bd4\u8f83\u56f0\u96be) - Gauss-Newton (\u6700\u4f18\u5316\u7b97\u6cd5\u6700\u7b80\u5355\u7684\u65b9\u6cd5\u4e4b\u4e00, \u5c06 \\(f(x)\\) \u8fdb\u884c\u4e00\u9636\u6cf0\u52d2\u5c55\u5f00\uff0c\u800c\u975e\u76ee\u6807\u51fd\u6570 \\(f(x)^2\\) ) $$ f(x + \\Delta x) \\approx f(x) + J(x)\\Delta x $$ \u8be5\u5f0f \\(J(x)\\) \u4e3a \\(f(x)\\) \u5173\u4e8e \\(x\\) \u7684\u5bfc\u6570\uff0c\u5f97\u7ebf\u6027\u6700\u5c0f\u4e8c\u4e58\u95ee\u9898\u4e3a: $$ \\Delta x^ k = arg\\min\\limits {\\Delta x}\\frac{1}{2} |f(x) + J(x)\\Delta x|^2 $$ \u5c06\u6700\u5c0f\u4e8c\u4e58\u95ee\u9898\u7684\u76ee\u6807\u51fd\u6570 \\(|f(x) + J(x)\\Delta x|^2\\) \u5bf9 \\(\\Delta x\\) \u6c42\u5bfc\u5e76\u4ee4\u5bfc\u6570\u4e3a\u96f6\u5f97 \u589e\u91cf\u65b9\u7a0b(\u9ad8\u65af\u725b\u987f\u65b9\u7a0bGaussNewtonEquations\u6216\u6b63\u89c4\u65b9\u7a0bNormalEquations) $$ J(x)^T J(x) \\Delta x = -J(x)f(x) \\sim H \\Delta x =g $$ Gauss-Newton\u5c06 \\(J^T J\\) \u4f5c\u4e3a\u725b\u987f\u6cd5\u4e2d\u4e8c\u9636 \\(Hessian\\) \u77e9\u9635\u7684\u8fd1\u4f3c\uff0c \u6c42\u89e3\u589e\u91cf\u65b9\u7a0b\u662f\u6574\u4e2a\u4f18\u5316\u95ee\u9898\u7684\u6838\u5fc3 * - Gauss-Newton\u7b97\u6cd5\u6b65\u9aa4 1. \u7ed9\u5b9a\u67d0\u4e2a\u521d\u59cb\u503c \\(x_0\\) 2. \u5bf9\u4e8e\u7b2c \\(\\mathcal{k}\\) \u6b21\u8fed\u4ee3\uff0c\u6c42\u51fa\u5f53\u524d\u7684Jacobian\u77e9\u9635 \\(J(x_k)\\) \u548c\u8bef\u5dee \\(f(x_k)\\) 3. \u6c42\u89e3\u589e\u91cf\u65b9\u7a0b: \\(H \\Delta x =g\\) 4. \u82e5 \\(\\Delta x_k\\) \u8db3\u591f\u5c0f\uff0c\u5219\u505c\u6b62\u3002\u5426\u5219\uff0c\u4ee4 \\(x_{k+1} = x_k + \\Delta x_k\\) ,\u7136\u540e\u8fd4\u56de\u6b65\u9aa42","title":"\u6700\u5c0f\u4e8c\u4e58\u95ee\u9898"},{"location":"m%26l/slam_imupre_liomapping/","text":"note of lio-mapping shortcomnigs - make featuring tracking an intractable problem - lidar mounted on moving robots suffer from motion distortion - there are some lidar-degraded cases in which the lidar receives few or missing points such as narrow corridor environments lead to ill-constrained pose estimation the paper's contributions as follows: - to achieve real-time and more consistent estimation,fixed-lag smoothing and marginalization of old poses are applied,followed by a rotation constrained refinement. - pre-integrate and use raw IMU measurements with lidar measurements to optimize the states within the whole system,which can work in laser degraded cases or when the motions are rapid. Notations - denote the transformation matrix as \\(\\mathbf{T}_b^a \\in SE(3)\\,[b \\to a]\\) , which transforms the point \\(\\mathbf{x}^b \\in \\mathbb{R}^3\\) in the frame \\(\\mathcal{F}_b\\) into the frame \\(\\mathcal{F}_a\\) ,just as [ \\(\\mathbf{T}_L^I\\) -> lidar / imu, transform point \\(P\\) from lidar frame \\(\\mathcal{F}_{lidar}\\) to imu frame \\(\\mathcal{F}_{imu}\\) ]. - denote the raw measurements of the IMU at timestamp \\(\\mathcal{k}\\) as \\(\\hat{a}_k\\) and \\(\\hat{w}_k\\) . - denote the extracted features as \\(\\mathbf{F}_a\\) in original \\(\\mathcal{F}_{lidar}\\) ,which can be transformed into the frame \\(\\mathcal{F}_b\\) as \\(\\mathbf{F}_a^b\\) . - robot body frame \\(\\mathcal{F}_B \\to imu\\) , and lidar body frame \\(\\mathcal{F}_L \\to lidar\\)","title":"Note after reading paper of lio-mapping"},{"location":"m%26l/slam_imupre_vins/","text":"note of VINS abstract \u00b6 \u901a\u8fc7\u6ed1\u7a97\u4f18\u5316\u89c6\u89c9\u548c\u60ef\u5bfc\u5b9e\u73b0\u7cbe\u786e\u7684\u72b6\u6001\u4f30\u8ba1,\u89c6\u89c9\u7ed3\u6784\u7531\u6ed1\u52a8\u7a97\u53e3\u5185\u7684\u5173\u952e\u5e27\u7ef4\u62a4,\u60ef\u6027\u7684metrix\u6d4b\u91cf\u503c\u7531\u5173\u952e\u5e27\u4e4b\u95f4\u7684\u9884\u79ef\u5206\u7ef4\u62a4\u3002\u7cfb\u7edf\u5728\u4f4d\u7f6e\u72b6\u6001\u4e0b\u4e5f\u53ef\u9c81\u68d2\u7684\u521d\u59cb\u5316,\u5e76\u80fd\u5b9e\u65f6\u5b9e\u73b0camera-imu\u7684\u6807\u5b9a,\u7edf\u4e00\u5b9a\u4e49\u5728\u7403\u9762\u4e0a\u7684\u91cd\u6295\u5f71\u8bef\u5dee\u3001\u56de\u73af\u68c0\u6d4b\u3001\u4ee5\u53ca4\u81ea\u7531\u5ea6\u7684\u4f4d\u59ff\u4f18\u5316 overview \u00b6 \u63d0\u53d6\u3001\u8ffd\u8e2a\u6bcf\u4e2aimage frame\u7684\u7279\u5f81\u70b9,\u5e76\u5728\u76f8\u90bb\u4e24\u5e27key-image\u4e4b\u95f4\u9884\u79ef\u5206imu\u6570\u636e \u521d\u59cb\u5316\u8fc7\u7a0b(\u63d0\u4f9bpose/velocity/gravityVector/gyroscopeBias/3DfeaturePoints\u6765\u5f15\u5bfc\u975e\u7ebf\u6027\u7cfb\u7edf) \u5b9e\u73b0\u975e\u7ebf\u6027\u56fe\u4f18\u5316\u901a\u8fc7\u4f18\u5316\u6240\u6709\u7684\u89c6\u89c9\u3001\u60ef\u5bfc\u6570\u636e\u6765\u4f18\u5316\u6ed1\u7a97\u5185\u72b6\u6001 \u5355\u72ec\u7684\u7ebf\u7a0b\u8d1f\u8d23\u95ed\u73af\u68c0\u6d4b\u548c\u4f4d\u59ff\u4f18\u5316 \u6d4b\u91cf\u503c\u9884\u5904\u7406 \u00b6 image,\u8fde\u7eed\u5e27\u4e4b\u95f4\u68c0\u6d4b\u7279\u5f81\u5e76\u5728\u4e0a\u4e00\u5e27\u68c0\u6d4b\u65b0\u7684\u7279\u5f81 imu: \u5728\u8fde\u7eed\u4e24\u5e27image\u4e4b\u95f4\u9884\u79ef\u5206\u3002\u6ce8:imu\u6570\u636e\u540c\u65f6\u88abnoise\u548cbias\u6240\u5f71\u54cd,\u6240\u4ee5\u5728\u9884\u79ef\u5206\u548c\u4f18\u5316\u8fc7\u7a0b\u4e2d\u90fd\u7279\u522b\u8003\u8651\u4e86bias,\u8fd9\u5728\u4f4e\u6210\u672c\u7684imu\u6570\u636e\u5904\u7406\u4e2d\u5f88\u91cd\u8981 A.\u524d\u7aef\u89c6\u89c9\u5904\u7406 \u00b6 \u9488\u5bf9\u6bcf\u4e00\u5f20\u56fe\u50cf,\u91c7\u7528KLT\u7a00\u758f\u5149\u6d41\u7b97\u6cd5\u8ffd\u8e2a\u7279\u5f81,\u540c\u65f6\u68c0\u6d4b\u89d2\u70b9\u6765\u4fdd\u6301\u6bcf\u5f20image\u7684\u6700\u5c0f\u7279\u5f81\u6570\u76ee,detector\u5f3a\u5236\u7edf\u4e00\u7684\u7279\u5f81\u5206\u5e03\u901a\u8fc7\u5728\u76f8\u90bbimage\u8bbe\u7f6e\u6700\u5c0f\u7684\u50cf\u7d20\u5dee\u4e2a\u6570\u3002 \u68c0\u6d4b\u5230\u7684\u7279\u5f81\u5728\u901a\u8fc7RANSAC\u6291\u5236\u79bb\u7fa4\u70b9\u540e\u88ab\u6620\u5c04\u5230\u5355\u4f4d\u7403\u4f53\u3002 key frame\u4e5f\u5728\u8fd9\u4e00\u6b65\u6839\u636e2\u4e2a\u6807\u51c6\u9009\u53d6:(1)\u901a\u8fc7\u8ffd\u8e2a\u7684\u5e73\u5747parallax\u89c6\u5dee\u9009\u53d6,\u89c6\u5dee\u8d85\u8fc7\u4e00\u5b9a\u9608\u503c\u5219\u4e3akey frame, \u5e73\u79fb\u548c\u65cb\u8f6c\u90fd\u4f1a\u5f15\u8d77\u89c6\u5dee,\u4f46\u53ea\u65cb\u8f6c\u4e0d\u80fd\u5b8c\u6210\u4e09\u89d2\u5316 ,\u4e3a\u4e86\u907f\u514d\u8fd9\u4e2a\u95ee\u9898\uff0c\u5728\u8ba1\u7b97\u89c6\u5deeparallax\u7684\u65f6\u5019\u4f7f\u7528imu\u79ef\u5206\u8865\u507f\u65cb\u8f6c (2)\u53e6\u4e00\u4e2a\u6807\u51c6\u662f\u8ffd\u8e2a\u7684\u8d28\u91cf,\u5982\u679c\u8ffd\u8e2a\u7684\u7279\u5f81\u6570\u91cf\u4f4e\u4e8e\u8bbe\u5b9a\u7684\u9608\u503c,\u6211\u4eec\u4e5f\u628a\u8fd9\u4e00\u8fd9\u5e27\u89c6\u4e3akeyframe B.IMU-Preintegration \u00b6 \u76f8\u6bd4\u4e4b\u524d\u7684\u5de5\u4f5c,\u6b64\u6b21\u96c6\u6210\u4e86IMU\u7684bias\u6821\u6b63,\u8fde\u7eed\u65f6\u5e8f\u4e0b\u52a8\u6001\u4f20\u64ad\u566a\u58f0,\u540c\u65f6IMU\u9884\u79ef\u5206\u7ed3\u679c\u4f1a\u5e94\u7528\u5230\u521d\u59cb\u5316\u6a21\u5757\u6765\u6821\u51c6\u521d\u59cb\u5316\u72b6\u6001","title":"Note after reading paper of VINS"},{"location":"m%26l/slam_imupre_vins/#abstract","text":"\u901a\u8fc7\u6ed1\u7a97\u4f18\u5316\u89c6\u89c9\u548c\u60ef\u5bfc\u5b9e\u73b0\u7cbe\u786e\u7684\u72b6\u6001\u4f30\u8ba1,\u89c6\u89c9\u7ed3\u6784\u7531\u6ed1\u52a8\u7a97\u53e3\u5185\u7684\u5173\u952e\u5e27\u7ef4\u62a4,\u60ef\u6027\u7684metrix\u6d4b\u91cf\u503c\u7531\u5173\u952e\u5e27\u4e4b\u95f4\u7684\u9884\u79ef\u5206\u7ef4\u62a4\u3002\u7cfb\u7edf\u5728\u4f4d\u7f6e\u72b6\u6001\u4e0b\u4e5f\u53ef\u9c81\u68d2\u7684\u521d\u59cb\u5316,\u5e76\u80fd\u5b9e\u65f6\u5b9e\u73b0camera-imu\u7684\u6807\u5b9a,\u7edf\u4e00\u5b9a\u4e49\u5728\u7403\u9762\u4e0a\u7684\u91cd\u6295\u5f71\u8bef\u5dee\u3001\u56de\u73af\u68c0\u6d4b\u3001\u4ee5\u53ca4\u81ea\u7531\u5ea6\u7684\u4f4d\u59ff\u4f18\u5316","title":"abstract"},{"location":"m%26l/slam_imupre_vins/#overview","text":"\u63d0\u53d6\u3001\u8ffd\u8e2a\u6bcf\u4e2aimage frame\u7684\u7279\u5f81\u70b9,\u5e76\u5728\u76f8\u90bb\u4e24\u5e27key-image\u4e4b\u95f4\u9884\u79ef\u5206imu\u6570\u636e \u521d\u59cb\u5316\u8fc7\u7a0b(\u63d0\u4f9bpose/velocity/gravityVector/gyroscopeBias/3DfeaturePoints\u6765\u5f15\u5bfc\u975e\u7ebf\u6027\u7cfb\u7edf) \u5b9e\u73b0\u975e\u7ebf\u6027\u56fe\u4f18\u5316\u901a\u8fc7\u4f18\u5316\u6240\u6709\u7684\u89c6\u89c9\u3001\u60ef\u5bfc\u6570\u636e\u6765\u4f18\u5316\u6ed1\u7a97\u5185\u72b6\u6001 \u5355\u72ec\u7684\u7ebf\u7a0b\u8d1f\u8d23\u95ed\u73af\u68c0\u6d4b\u548c\u4f4d\u59ff\u4f18\u5316","title":"overview"},{"location":"m%26l/slam_imupre_vins/#_1","text":"image,\u8fde\u7eed\u5e27\u4e4b\u95f4\u68c0\u6d4b\u7279\u5f81\u5e76\u5728\u4e0a\u4e00\u5e27\u68c0\u6d4b\u65b0\u7684\u7279\u5f81 imu: \u5728\u8fde\u7eed\u4e24\u5e27image\u4e4b\u95f4\u9884\u79ef\u5206\u3002\u6ce8:imu\u6570\u636e\u540c\u65f6\u88abnoise\u548cbias\u6240\u5f71\u54cd,\u6240\u4ee5\u5728\u9884\u79ef\u5206\u548c\u4f18\u5316\u8fc7\u7a0b\u4e2d\u90fd\u7279\u522b\u8003\u8651\u4e86bias,\u8fd9\u5728\u4f4e\u6210\u672c\u7684imu\u6570\u636e\u5904\u7406\u4e2d\u5f88\u91cd\u8981","title":"\u6d4b\u91cf\u503c\u9884\u5904\u7406"},{"location":"m%26l/slam_imupre_vins/#a","text":"\u9488\u5bf9\u6bcf\u4e00\u5f20\u56fe\u50cf,\u91c7\u7528KLT\u7a00\u758f\u5149\u6d41\u7b97\u6cd5\u8ffd\u8e2a\u7279\u5f81,\u540c\u65f6\u68c0\u6d4b\u89d2\u70b9\u6765\u4fdd\u6301\u6bcf\u5f20image\u7684\u6700\u5c0f\u7279\u5f81\u6570\u76ee,detector\u5f3a\u5236\u7edf\u4e00\u7684\u7279\u5f81\u5206\u5e03\u901a\u8fc7\u5728\u76f8\u90bbimage\u8bbe\u7f6e\u6700\u5c0f\u7684\u50cf\u7d20\u5dee\u4e2a\u6570\u3002 \u68c0\u6d4b\u5230\u7684\u7279\u5f81\u5728\u901a\u8fc7RANSAC\u6291\u5236\u79bb\u7fa4\u70b9\u540e\u88ab\u6620\u5c04\u5230\u5355\u4f4d\u7403\u4f53\u3002 key frame\u4e5f\u5728\u8fd9\u4e00\u6b65\u6839\u636e2\u4e2a\u6807\u51c6\u9009\u53d6:(1)\u901a\u8fc7\u8ffd\u8e2a\u7684\u5e73\u5747parallax\u89c6\u5dee\u9009\u53d6,\u89c6\u5dee\u8d85\u8fc7\u4e00\u5b9a\u9608\u503c\u5219\u4e3akey frame, \u5e73\u79fb\u548c\u65cb\u8f6c\u90fd\u4f1a\u5f15\u8d77\u89c6\u5dee,\u4f46\u53ea\u65cb\u8f6c\u4e0d\u80fd\u5b8c\u6210\u4e09\u89d2\u5316 ,\u4e3a\u4e86\u907f\u514d\u8fd9\u4e2a\u95ee\u9898\uff0c\u5728\u8ba1\u7b97\u89c6\u5deeparallax\u7684\u65f6\u5019\u4f7f\u7528imu\u79ef\u5206\u8865\u507f\u65cb\u8f6c (2)\u53e6\u4e00\u4e2a\u6807\u51c6\u662f\u8ffd\u8e2a\u7684\u8d28\u91cf,\u5982\u679c\u8ffd\u8e2a\u7684\u7279\u5f81\u6570\u91cf\u4f4e\u4e8e\u8bbe\u5b9a\u7684\u9608\u503c,\u6211\u4eec\u4e5f\u628a\u8fd9\u4e00\u8fd9\u5e27\u89c6\u4e3akeyframe","title":"A.\u524d\u7aef\u89c6\u89c9\u5904\u7406"},{"location":"m%26l/slam_imupre_vins/#bimu-preintegration","text":"\u76f8\u6bd4\u4e4b\u524d\u7684\u5de5\u4f5c,\u6b64\u6b21\u96c6\u6210\u4e86IMU\u7684bias\u6821\u6b63,\u8fde\u7eed\u65f6\u5e8f\u4e0b\u52a8\u6001\u4f20\u64ad\u566a\u58f0,\u540c\u65f6IMU\u9884\u79ef\u5206\u7ed3\u679c\u4f1a\u5e94\u7528\u5230\u521d\u59cb\u5316\u6a21\u5757\u6765\u6821\u51c6\u521d\u59cb\u5316\u72b6\u6001","title":"B.IMU-Preintegration"},{"location":"m%26l/slam_loam_series/","text":"this blog conclud from loam(Ji Zhang),LeGO-LOAM&LIO-SAM(Tixiao Shan) State estimation, localization and mapping are fundamental prerequisites for a successful intelligent mobile robot,required for feedback control, obstacle avoidance, and planning, among many other capabilities.Using vision-based and lidar-based sensing,great efforts have been devoted to achiving high-performance real-time simultaneous localization and mapping(SLAM) that can support a mobile robot's six degree-of-freedom state estimation. Vision-based methods typically use a monocular or stereo camera and triangulate features across successive images to determine the camera motion.Although vision-based methods are especially suitable for palce recognition,their sensitivity to initialization,illumination and range make them unreliable when they alone are used to supportan autonomous navigation system. On the other hand, lidar-based methods are largely invariant to illumination change,Especially with the availability of long-range,high-resolution 3D liar,becomes more suitable to directly capture the fine details of an environment in 3D space.Therefor there was researchs among loam,lego-loam and lio-sam, those paper focuses on lidar-based state estimation and mappnig methods. method strenght weakness vision-based --more suitable for place recognition --better in loop-closure detection --sensitive to illumination --view point change may make it unreliable lidar-based --work normally at night --captrure more details about environment at long ranges --bigger angle-view a Desc about loam lego-loam lio-sam \u00b6 method strength weakness IMU loam --low-drift and real-time --correct the motion distortion of pointcloud --feature-based scan matching: edge with edge and planar with planar to ensure fats computation becase of its less computational resources requirement --good strategy: coarse processing at high frequency to estimate veocity, fine processing at low frequency to create map --saving data in a global voxel map,online optimization process will less efficient when the global voxel map becomes dense in a feature-rich areas --difficult to perform loop closure detection and incorporate other absolute measurements,e.g GPS for pose correction --loam suffers from drift in large-scale test, as it is a scan-matching based method at its core --not very universal to different lidars:the method of extracting features are integrated with the rotating lidar tightly --de-skew the lidar scan,that is motion compensator --provide a motion prior for scan-matching -- loosely-coupled :IMU is not involved in the optimization process of the algorithm lego-loam --lightweight and ground-optimized lidar odom --two step L-M optimization computes pose transformation separately --add loop closure same as loam lio-sam --a tightly-coupled lidar inertial odometry framework built atop a factor graph,which is suitable for multi-sensor fusion and global optimization --an efficient,local sliding window-based scan-matching approach that enables real-time performance by registering selectively chosen new keyframes to a fixed-size set of prior sub-keyframes lidar motion compensator \u00b6 A scan's point cloud is often skewed because of the rotation mechanism of modern 3D lidar and sensor motion.Solely using lidar for pose estimation is not ideal since registration using skewed pointclouds or features will eventually cause large drift. Therefore, lidar is typically used in conjunction with other sensors, such as GPS and IMU, for state estimation and ampping. LOAM \u00b6 Assume \u00b6 lidar is pre-calibrated angular and linear velocities of the lidar are smooth and continuous over time without abrupt changes Feature Point Extraction \u00b6 we select feature point that are on sharp edges and planar surface patches, Let \\(i\\) be a point in \\(P_k\\) , and let \\(S\\) be the set of consecutive points of \\(i\\) returned by the laser scanner in the same scan. 1. Calculate the smoothness \\(c\\) of the local surface at point i, where \\(i \\in P_k\\) $$ c = \\frac{1}{|S|\\cdot|X^L_{(k,i)}|}\\cdot|\\sum_{j\\in S,j\\neq i}(X^L_{(k,i)} - X^L_{(k,j)})|\\tag{1} $$ 2. The points in a scan are sorted based on the \\(c\\) values. To evenly distribute the feature points within the environment,we separate a scan to four identical subregions.Each subregion can provide maximally 2 edge points and 4 planar points $$ bool\u00a9= \\begin{cases} c > threshold, & \\text{dege points} \\\\ c < threshold, & \\text{planar points} \\end{cases} $$ we try to avoid points whose surrounded points are selected,or points on local planar surfaces that are roughly parallel to the laser beams are usually considered as unreliable. we also try to avoid points that are on boundary of occluded regions Conclusion feature points are selected as edge points starting from the maximum \\(c\\) value, and planarpoints starting from the minimum \\(c\\) value, and if a point is selected, - The number of selected edge points or planar points cannot exceed the maximum of thesubregion - None of its surrounding point is already selected - It cannot be on a surface patch that is roughly parallel to the laser beam, or on boundaryof an occluded region. Find Feature Point Correspondence \u00b6 The odometry algorithm estimates motion of the lidar within a sweep(frame),Let \\(t_k\\) be the starting time of a sweep \\(k\\) . At the end of each sweep, the point cloud perceived during the sweep, \\(P_k\\) , is reprojected to time stamp \\(t_{k+1}\\) .we denote the reprojected sweep(frame) as \\(\\bar{P_{k}}\\) .During the next sweep \\(k+1\\) , \\(\\bar{P_{k}}\\) is used together with the newly received point cloud \\(P_{k+1}\\) , to estimate the motion of the lidar. raw frame corrected frame edge pts planar pts \\(P_k\\) during [ \\(t_k,t_{k+1}\\) ] \\(\\bar{P}\\_k\\) by reprojected \\(P_k\\) to timesatmp \\(t_{k+1}\\) \\(\\mathcal{E}_k\\) edge pts from \\(\\bar{P}_k\\) \\(\\mathcal{H}_k\\) planar pts from \\(\\bar{P}_k\\) \\(P_{k+1}\\) during [ \\(t_{k+1},t_{k+2}\\) ] \\(\\bar{P}\\_{k+1}\\) by reprojected \\(P_{k+1}\\) to timesatmp \\(t_{k+1}\\) \\(\\mathcal{E}\\_{k+1}\\) edge pts from \\(\\bar{P}\\_{k+1}\\) \\(\\mathcal{H}\\_{k+1}\\) planar pts from \\(\\bar{P}\\_{k+1}\\) Source of Feature Points At each iteration, \\(\\mathcal{E}\\_{k+1}\\) and \\(\\mathcal{H}\\_{k+1}\\) are reprojected point sets at the beginning of the sweep \\(\\bar{P}\\_{k+1}\\) by using currently estimated transform. For each point in \\(\\mathcal{E}\\_{k+1}\\) and \\(\\mathcal{H}\\_{k+1}\\) ,we are going to find the closest neighbor point in \\(\\bar{P}\\_k\\) ,which is stored in a 3D KD-tree for fast index. Find the closest points in \\(\\mathcal{E}\\_{k}\\) and \\(\\mathcal{H}\\_{k}\\) for each point of \\(\\mathcal{E}\\_{k+1}\\) and \\(\\mathcal{H}\\_{k+1}\\) find closest edge points in \\(\\mathcal{E}\\_{k}\\) for each point of \\(\\mathcal{E}\\_{k+1}\\) let \\(X^L_{(k+1,i)}\\) denote the point \\(\\mathcal{i} \\in \\mathcal{E}\\_{k+1}\\) ,which is in LidarCoordinateSystem{ \\(L\\) } the edge line is represented by two points,points \\(j \\in \\mathcal{E}\\_k\\) and \\(l \\in \\mathcal{E}\\_k\\) are closest neighbor of \\(i\\) in consecutive scans. Notice we particularly require that \\(j\\) and \\(l\\) are from different scans considering that a single scan cannot contain more than one points from the same dege line find closest planar points in \\(\\mathcal{H}\\_{k}\\) for each point of \\(\\mathcal{H}\\_{k+1}\\) the planar patch is represented by three points,similar to last,we find the closest neighbor of \\(i\\) in \\(\\bar{P}_k\\) ,denote as \\(j\\) , \\(l\\) , \\(m\\) Notice about \\(j\\) , \\(l\\) , \\(m\\) ,two of them are on the same scan, another is in consecutive scans,This guarantees that the three points are non-collinear compute the distance between every feature point of \\(\\bar{P}\\_{k+1}\\) to the closest neighbor points of \\(\\bar{P}\\_{k}\\) Notice all points in the formula ( \\(\\mathcal{2}\\) ) and ( \\(\\mathcal{3}\\) ) is the coordinates in { \\(L\\) }. $$ d\\varepsilon = \\frac{|(\\widetilde{X}^L_{(k+1,i)}- \\bar{X}^L_{(k,j)})\\times (\\widetilde{X}^L_{(k+1,i)}- \\bar{X} L_{(k,l)})|}{|\\bar{X} L_{(k,j)} - \\bar{X}^L_{(k,l)}|} .\\text{distance of point to line} \\tag{2} $$ $$ d_{\\mathcal{H}} = \\frac{|(\\widetilde{X}^L_{(k+1, i)} - \\bar{X} L_{(k,j)})\\cdot((\\bar{X} L_{(k,j)} - \\bar{X} L_{(k,l)})\\times(\\bar{X} L_{(k,j)} - \\bar{X}^L_{(k,m)}))|} {|(\\bar{X}^L_{(k,l)} - \\bar{X} L_{(k,j)})\\times(\\bar{X} L_{(k,m)} - \\bar{X}^L_{(k,j)})|}.\\text{distance of point to planar}\\tag{3} $$ - Motion Estimation TODO - Corrected every point for a sweep - Motion estimation between two consecutive sweep LIO-SAM \u00b6 Assume \u00b6 assume nonlinear motion model for point cloud de-skew,estimate the sensor motion during a lidar scan using raw IMU measurements the estimated motion above also serve as an intial guess for lidar odometry optimization the lidar-odometry result above is then used to estimate the bias of the IMU in the factor graph.","title":"Note after reading paper of loam"},{"location":"m%26l/slam_loam_series/#desc-about-loam-lego-loam-lio-sam","text":"method strength weakness IMU loam --low-drift and real-time --correct the motion distortion of pointcloud --feature-based scan matching: edge with edge and planar with planar to ensure fats computation becase of its less computational resources requirement --good strategy: coarse processing at high frequency to estimate veocity, fine processing at low frequency to create map --saving data in a global voxel map,online optimization process will less efficient when the global voxel map becomes dense in a feature-rich areas --difficult to perform loop closure detection and incorporate other absolute measurements,e.g GPS for pose correction --loam suffers from drift in large-scale test, as it is a scan-matching based method at its core --not very universal to different lidars:the method of extracting features are integrated with the rotating lidar tightly --de-skew the lidar scan,that is motion compensator --provide a motion prior for scan-matching -- loosely-coupled :IMU is not involved in the optimization process of the algorithm lego-loam --lightweight and ground-optimized lidar odom --two step L-M optimization computes pose transformation separately --add loop closure same as loam lio-sam --a tightly-coupled lidar inertial odometry framework built atop a factor graph,which is suitable for multi-sensor fusion and global optimization --an efficient,local sliding window-based scan-matching approach that enables real-time performance by registering selectively chosen new keyframes to a fixed-size set of prior sub-keyframes","title":"Desc about loam lego-loam lio-sam"},{"location":"m%26l/slam_loam_series/#lidar-motion-compensator","text":"A scan's point cloud is often skewed because of the rotation mechanism of modern 3D lidar and sensor motion.Solely using lidar for pose estimation is not ideal since registration using skewed pointclouds or features will eventually cause large drift. Therefore, lidar is typically used in conjunction with other sensors, such as GPS and IMU, for state estimation and ampping.","title":"lidar motion compensator"},{"location":"m%26l/slam_loam_series/#loam","text":"","title":"LOAM"},{"location":"m%26l/slam_loam_series/#assume","text":"lidar is pre-calibrated angular and linear velocities of the lidar are smooth and continuous over time without abrupt changes","title":"Assume"},{"location":"m%26l/slam_loam_series/#feature-point-extraction","text":"we select feature point that are on sharp edges and planar surface patches, Let \\(i\\) be a point in \\(P_k\\) , and let \\(S\\) be the set of consecutive points of \\(i\\) returned by the laser scanner in the same scan. 1. Calculate the smoothness \\(c\\) of the local surface at point i, where \\(i \\in P_k\\) $$ c = \\frac{1}{|S|\\cdot|X^L_{(k,i)}|}\\cdot|\\sum_{j\\in S,j\\neq i}(X^L_{(k,i)} - X^L_{(k,j)})|\\tag{1} $$ 2. The points in a scan are sorted based on the \\(c\\) values. To evenly distribute the feature points within the environment,we separate a scan to four identical subregions.Each subregion can provide maximally 2 edge points and 4 planar points $$ bool\u00a9= \\begin{cases} c > threshold, & \\text{dege points} \\\\ c < threshold, & \\text{planar points} \\end{cases} $$ we try to avoid points whose surrounded points are selected,or points on local planar surfaces that are roughly parallel to the laser beams are usually considered as unreliable. we also try to avoid points that are on boundary of occluded regions Conclusion feature points are selected as edge points starting from the maximum \\(c\\) value, and planarpoints starting from the minimum \\(c\\) value, and if a point is selected, - The number of selected edge points or planar points cannot exceed the maximum of thesubregion - None of its surrounding point is already selected - It cannot be on a surface patch that is roughly parallel to the laser beam, or on boundaryof an occluded region.","title":"Feature Point Extraction"},{"location":"m%26l/slam_loam_series/#find-feature-point-correspondence","text":"The odometry algorithm estimates motion of the lidar within a sweep(frame),Let \\(t_k\\) be the starting time of a sweep \\(k\\) . At the end of each sweep, the point cloud perceived during the sweep, \\(P_k\\) , is reprojected to time stamp \\(t_{k+1}\\) .we denote the reprojected sweep(frame) as \\(\\bar{P_{k}}\\) .During the next sweep \\(k+1\\) , \\(\\bar{P_{k}}\\) is used together with the newly received point cloud \\(P_{k+1}\\) , to estimate the motion of the lidar. raw frame corrected frame edge pts planar pts \\(P_k\\) during [ \\(t_k,t_{k+1}\\) ] \\(\\bar{P}\\_k\\) by reprojected \\(P_k\\) to timesatmp \\(t_{k+1}\\) \\(\\mathcal{E}_k\\) edge pts from \\(\\bar{P}_k\\) \\(\\mathcal{H}_k\\) planar pts from \\(\\bar{P}_k\\) \\(P_{k+1}\\) during [ \\(t_{k+1},t_{k+2}\\) ] \\(\\bar{P}\\_{k+1}\\) by reprojected \\(P_{k+1}\\) to timesatmp \\(t_{k+1}\\) \\(\\mathcal{E}\\_{k+1}\\) edge pts from \\(\\bar{P}\\_{k+1}\\) \\(\\mathcal{H}\\_{k+1}\\) planar pts from \\(\\bar{P}\\_{k+1}\\) Source of Feature Points At each iteration, \\(\\mathcal{E}\\_{k+1}\\) and \\(\\mathcal{H}\\_{k+1}\\) are reprojected point sets at the beginning of the sweep \\(\\bar{P}\\_{k+1}\\) by using currently estimated transform. For each point in \\(\\mathcal{E}\\_{k+1}\\) and \\(\\mathcal{H}\\_{k+1}\\) ,we are going to find the closest neighbor point in \\(\\bar{P}\\_k\\) ,which is stored in a 3D KD-tree for fast index. Find the closest points in \\(\\mathcal{E}\\_{k}\\) and \\(\\mathcal{H}\\_{k}\\) for each point of \\(\\mathcal{E}\\_{k+1}\\) and \\(\\mathcal{H}\\_{k+1}\\) find closest edge points in \\(\\mathcal{E}\\_{k}\\) for each point of \\(\\mathcal{E}\\_{k+1}\\) let \\(X^L_{(k+1,i)}\\) denote the point \\(\\mathcal{i} \\in \\mathcal{E}\\_{k+1}\\) ,which is in LidarCoordinateSystem{ \\(L\\) } the edge line is represented by two points,points \\(j \\in \\mathcal{E}\\_k\\) and \\(l \\in \\mathcal{E}\\_k\\) are closest neighbor of \\(i\\) in consecutive scans. Notice we particularly require that \\(j\\) and \\(l\\) are from different scans considering that a single scan cannot contain more than one points from the same dege line find closest planar points in \\(\\mathcal{H}\\_{k}\\) for each point of \\(\\mathcal{H}\\_{k+1}\\) the planar patch is represented by three points,similar to last,we find the closest neighbor of \\(i\\) in \\(\\bar{P}_k\\) ,denote as \\(j\\) , \\(l\\) , \\(m\\) Notice about \\(j\\) , \\(l\\) , \\(m\\) ,two of them are on the same scan, another is in consecutive scans,This guarantees that the three points are non-collinear compute the distance between every feature point of \\(\\bar{P}\\_{k+1}\\) to the closest neighbor points of \\(\\bar{P}\\_{k}\\) Notice all points in the formula ( \\(\\mathcal{2}\\) ) and ( \\(\\mathcal{3}\\) ) is the coordinates in { \\(L\\) }. $$ d\\varepsilon = \\frac{|(\\widetilde{X}^L_{(k+1,i)}- \\bar{X}^L_{(k,j)})\\times (\\widetilde{X}^L_{(k+1,i)}- \\bar{X} L_{(k,l)})|}{|\\bar{X} L_{(k,j)} - \\bar{X}^L_{(k,l)}|} .\\text{distance of point to line} \\tag{2} $$ $$ d_{\\mathcal{H}} = \\frac{|(\\widetilde{X}^L_{(k+1, i)} - \\bar{X} L_{(k,j)})\\cdot((\\bar{X} L_{(k,j)} - \\bar{X} L_{(k,l)})\\times(\\bar{X} L_{(k,j)} - \\bar{X}^L_{(k,m)}))|} {|(\\bar{X}^L_{(k,l)} - \\bar{X} L_{(k,j)})\\times(\\bar{X} L_{(k,m)} - \\bar{X}^L_{(k,j)})|}.\\text{distance of point to planar}\\tag{3} $$ - Motion Estimation TODO - Corrected every point for a sweep - Motion estimation between two consecutive sweep","title":"Find Feature Point Correspondence"},{"location":"m%26l/slam_loam_series/#lio-sam","text":"","title":"LIO-SAM"},{"location":"m%26l/slam_loam_series/#assume_1","text":"assume nonlinear motion model for point cloud de-skew,estimate the sensor motion during a lidar scan using raw IMU measurements the estimated motion above also serve as an intial guess for lidar odometry optimization the lidar-odometry result above is then used to estimate the bias of the IMU in the factor graph.","title":"Assume"},{"location":"m%26l/segmentation/cloud-segmentation-hdmap/","text":"\u57fa\u672c\u6d41\u7a0b\uff1a 1. \u5206\u5272\u5730\u9762\u70b9\u548c\u975e\u5730\u9762\u70b9 2. \u57fa\u4e8e\u975e\u5730\u9762\u70b9\u8fdb\u884c\u70b9\u4e91\u5206\u5272 3. \u5b9e\u65f6\u52a0\u8f7dhdmap\u5c06\u4f4d\u4e8e\u9053\u8def\u4e0a\u7684\u5206\u5272\u7ed3\u679c\u8fdb\u53bb\u6ee4\u51fa(\u4ea6\u53ef\u901a\u8fc7tracking\u5c06\u52a8\u6001\u969c\u788d\u7269\u6ee4\u9664) \u6574\u4f53\u6982\u89c8 \u00b6 \u5de6\u4e0b\u89d2\u4e3a\u539f\u59cb\u70b9\u4e91\u6570\u636e \u53f3\u4e0b\u89d2\u4e3a\u68c0\u6d4b\u7684\u5730\u9762\u70b9\u4e91 \u5de6\u4e0a\u89d2\u4e3a\u5206\u5272\u7684\u7ed3\u679c(\u5df2\u6839\u636ehdmap\u6ee4\u51fa\u4f4d\u4e8e\u9053\u8def\u4e0a\u7684\u52a8\u6001\u969c\u788d\u7269) \u53f3\u4e0a\u89d2\u4e3a\u6ee4\u51fa\u52a8\u6001\u969c\u788d\u7269\u540e\u70b9\u4e91 \u5730\u9762\u7684\u5206\u5272 \u00b6 \u91c7\u7528\u6781\u5750\u6807\u6295\u5f71\u7f51\u683c\u548c\u5e73\u9762\u62df\u5408\u7684\u65b9\u6cd5 \u70b9\u4e91\u805a\u7c7b \u00b6 \u91c7\u7528\u7f51\u683c\u6295\u5f71->\u81a8\u80c0->\u8fde\u901a\u5206\u6790->\u6536\u7f29","title":"cloud segmentation and filtered by hdmap"},{"location":"m%26l/segmentation/cloud-segmentation-hdmap/#_1","text":"\u5de6\u4e0b\u89d2\u4e3a\u539f\u59cb\u70b9\u4e91\u6570\u636e \u53f3\u4e0b\u89d2\u4e3a\u68c0\u6d4b\u7684\u5730\u9762\u70b9\u4e91 \u5de6\u4e0a\u89d2\u4e3a\u5206\u5272\u7684\u7ed3\u679c(\u5df2\u6839\u636ehdmap\u6ee4\u51fa\u4f4d\u4e8e\u9053\u8def\u4e0a\u7684\u52a8\u6001\u969c\u788d\u7269) \u53f3\u4e0a\u89d2\u4e3a\u6ee4\u51fa\u52a8\u6001\u969c\u788d\u7269\u540e\u70b9\u4e91","title":"\u6574\u4f53\u6982\u89c8"},{"location":"m%26l/segmentation/cloud-segmentation-hdmap/#_2","text":"\u91c7\u7528\u6781\u5750\u6807\u6295\u5f71\u7f51\u683c\u548c\u5e73\u9762\u62df\u5408\u7684\u65b9\u6cd5","title":"\u5730\u9762\u7684\u5206\u5272"},{"location":"m%26l/segmentation/cloud-segmentation-hdmap/#_3","text":"\u91c7\u7528\u7f51\u683c\u6295\u5f71->\u81a8\u80c0->\u8fde\u901a\u5206\u6790->\u6536\u7f29","title":"\u70b9\u4e91\u805a\u7c7b"},{"location":"m%26l/segmentation/cloud-segmentation/","text":"\u627e\u5230\u8f83\u65e9\u671f\u6574\u7406\u7684\u6587\u6863, \u4fdd\u5b58\u4e00\u4e0b\u5230blog. \u4f20\u7edf\u5206\u5272\u65b9\u6cd5 \u00b6 \u5178\u578b\u65b9\u6cd5pcl\u53c2\u89c1 pcl documentation ,\u4e14\u6709\u4f7f\u7528\u5b9e\u4f8b \u57fa\u4e8e\u51e0\u4f55\u7279\u5f81 \u00b6 \u57fa\u4e8esphere/cone/plane/cylinder\u7b49\u6570\u5b66\u89c4\u5219\u8fdb\u884c\u62df\u5408 \u533a\u57df\u589e\u957f(\u5e94\u7528\u5e7f\u6cdb\u3001\u6301\u7eed\u7814\u7a76\u4e2d) \u00b6 \u57fa\u4e8e\u5404\u79cd\u7279\u5f81\u53ca\u7ec4\u5408\u7279\u5f81\u7684\u533a\u57df\u589e\u957f(\u6b27\u5f0f\u8ddd\u79bb\u805a\u7c7b\u672c\u8d28\u4e3a\u533a\u57df\u589e\u957f,\u5224\u65ad\u6b27\u5f0f\u8ddd\u79bb)\u7b49\u3002 \u6838\u5fc3\u601d\u60f3\u5c31\u662f\u4ece\u4e00\u4e2a\u70b9\u51fa\u53d1,\u4f9d\u636e\u7ea6\u675f\u6761\u4ef6(\u8ddd\u79bb\u3001\u6cd5\u5411\u91cf\u3001\u5bc6\u5ea6\u5ea6\u91cf\u3001\u51f9\u51f8\u6027\u3001\u66f2\u7387\u7b49)\u6700\u7ec8\u589e\u957f\u6269\u6563\u4e3a\u4e00\u7c07 \u57fa\u672c\u6d41\u7a0b \u70b9\u4e91\u7279\u5f81 \u6700\u5c0f\u5206\u5272 \u00b6 \u57fa\u4e8e\u56fe\u8bba,\u5e94\u7528\u7f51\u7edc\u89c4\u5212,\u6c42\u89e3\u6865\u95ee\u9898,\u56fe\u50cf\u5206\u5272\u7b49\u9886\u57df,\u88ab\u79fb\u690d\u5230\u70b9\u4e91\u5206\u5272,\u70b9\u4e4b\u95f4\u8fde\u63a5\u4e3a\u56fe,\u8d4b\u4e88\u8fde\u7ebf\u6743\u503c,\u83b7\u5f97\u70b9\u4e4b\u95f4\u7684\u62d3\u6251\u5173\u7cfb\uff0c\u5206\u5272\u76ee\u6807\u9700\u8981\u4eba\u4e3a\u6307\u5b9a(\u5982\u6307\u5b9a\u4e86\u76ee\u6807\u7269\u4f53\u4e0a\u7684\u4e00\u4e2a\u70b9)!!!\u3002 \u57fa\u4e8e\u5f62\u6001\u5b66\u5206\u5272(\u56fe\u50cf\u5904\u7406\u7b97\u6cd5\u884d\u751f\u5230\u70b9\u4e91) \u00b6 \u822a\u7a7a\u6444\u5f71\u6d4b\u91cf\u4e2d\u4e3a\u53bb\u9664\u5730\u9762\u566a\u58f0\u5bf9\u5730\u5f62\u6d4b\u91cf\u7684\u5f71\u54cd,\u4e0d\u4f7f\u7528\u5730\u9762\u5e73\u6574\u5047\u8bbe\u7684\u524d\u63d0\u4e0b\u83b7\u5f97\u5730\u9762\u673a\u8f7dlidar \u6d4b\u91cf\u65b9\u5411\u548c\u5730\u9762\u5782\u76f4,\u5f62\u6210xy->z\u6620\u5c04(z\u65b9\u5411\u7684\u8303\u56f4\u8fdc\u8fdc\u5c0f\u4e8exy\u65b9\u5411),z\u65b9\u5411\u4ee3\u8868\u5730\u9762\u7269\u4f53\u7684\u9ad8\u5ea6,x,y\u65b9\u5411\u4e3a\u5e73\u884c\u4e0e\u5730\u9762\u4e14\u76f8\u4e92\u5782\u76f4\u7684\u4e24\u4e2a\u8f74 \u8d85\u4f53\u805a\u7c7b \u00b6 \u57fa\u4e8eOctree\u516b\u53c9\u6811\u5bf9\u70b9\u4e91\u8fdb\u884c\u5212\u5206\u5747\u5300\u5206\u5e03,\u83b7\u5f97\u4e0d\u540c\u70b9\u56e2\u4e4b\u95f4\u7684\u90bb\u63a5\u5173\u7cfb \u6240\u6709\u7684\u6676\u6838(seed)\u540c\u65f6\u5f00\u59cb\u751f\u957f,\u6700\u7ec8\u586b\u6ee1\u6574\u4e2a\u7a7a\u95f4\u5b8c\u6210\u5206\u5272,\u672c\u8d28\u8fd8\u662f\u57fa\u4e8e\u533a\u57df\u751f\u957f\u601d\u60f3\u3002 \u9996\u5148\u9700\u8981\u89c4\u5f8b\u7684\u5e03\u7f6e\u533a\u57df\u751f\u957f\u6676\u6838(\u6676\u6838\u5728\u7a7a\u95f4\u4e2d\u5b9e\u9645\u4e0a\u662f\u5747\u5300\u5206\u5e03), \u5e76\u6307\u5b9a\u6676\u6838\u8ddd\u79bb(Rseed),\u7c92\u5b50\u8ddd\u79bb(Rvoxel),\u6700\u5c0f\u6676\u7c92(MOV),\u8fc7\u5c0f\u7684\u6676\u7c92\u9700\u8981\u878d\u5165\u6700\u8fd1\u7684\u5927\u6676\u7c92 \u6709\u4e86\u6676\u6838(seed)\u548c\u7ed3\u6676\u8303\u56f4(\u641c\u7d22\u534a\u5f84)\u4e4b\u540e,\u7136\u540e\u63a7\u5236\u7ed3\u6676\u8fc7\u7a0b(\u589e\u957f\u7ea6\u675f\u6761\u4ef6)\u4ee5\u5b8c\u6210\u5206\u5272 LCCP(Locally Convex Connected Pathches)\u57fa\u4e8e\u8d85\u4f53\u805a\u7c7b(\u51f9\u51f8\u5173\u7cfb) \u00b6 \u57fa\u4e8e\u8d85\u4f53\u805a\u7c7b\u5b9e\u73b0\u8fc7\u5206\u5272 \u57fa\u4e8e\u7a7a\u95f4\u4fe1\u606f\u548c\u6cd5\u7ebf\u4fe1\u606f,\u5728\u8d85\u4f53\u805a\u7c7b\u7684\u57fa\u7840\u4e0a\u518d\u805a\u7c7b\u53bb\u9664\u8fc7\u5206\u5272 \u5bf9\u4e8e\u8fc7\u5206\u5272\u7684\u70b9\u4e91\u8ba1\u7b97\u4e0d\u540c\u7684\u5757\u4e4b\u95f4\u51f9\u51f8\u5173\u7cfb\u5e76\u8bb0\u5f55,\u7136\u540e\u57fa\u4e8e\u533a\u57df\u589e\u957f\u5c06\u5c0f\u533a\u57df\u805a\u7c7b\u6210\u8f83\u5927\u7684\u7269\u4f53(\u53ea\u5141\u8bb8\u533a\u57df\u8de8\u8d8a\u51f8\u8fb9\u589e\u957f) \u6295\u5f71\u65b9\u6cd5(\u7ef4\u5ea6\u635f\u5931) \u00b6 \u57fa\u4e8e\u865a\u62df\u56fe\u50cf\u5e73\u9762\u6295\u5f71 \u5c06\u70b9\u4e91\u6295\u5f71\u4e3arang-image/intensity-image\u57fa\u4e8e\u6fc0\u5149\u675f\u7279\u6027\u3001\u548c\u96f7\u8fbe\u81ea\u8eab\u53c2\u6570\u76f8\u5173 \u57fa\u4e8e2D-Grid\u5730\u9762\u65b9\u683c\u6216\u6781\u5750\u6807\u683c\u6295\u5f71(DAPAR\u6311\u6218\u8d5b\u4e2d\u5e7f\u6cdb\u4f7f\u7528) \u6295\u5f71\u52302D-grid raster\u53c2\u6570\u6839\u636e\u70b9\u4e91\u6570\u636e\u8c03\u6574,\u5355\u72ec\u4f7f\u7528\u5bb9\u6613\u5206\u5272\u4e0d\u8db3\u6216\u8fc7\u5206\u5272 \u6df1\u5ea6\u5b66\u4e60 \u00b6 3D grid+PointNet+3D CNN\u3001 MinCut\u3001KPCon\u3001 RS-CNN....\u8bed\u4e49\u5206\u5272 Hugues et al KPConv.arXiv 2019 pointpillar \u51c6\u786e\u7387\u3001\u53ec\u56de\u7387\u4e4b\u95f4\u8f83\u597d\u7684\u5e73\u8861","title":"\u70b9\u4e91\u5206\u5272\u7684\u57fa\u672c\u8c03\u7814"},{"location":"m%26l/segmentation/cloud-segmentation/#_1","text":"\u5178\u578b\u65b9\u6cd5pcl\u53c2\u89c1 pcl documentation ,\u4e14\u6709\u4f7f\u7528\u5b9e\u4f8b","title":"\u4f20\u7edf\u5206\u5272\u65b9\u6cd5"},{"location":"m%26l/segmentation/cloud-segmentation/#_2","text":"\u57fa\u4e8esphere/cone/plane/cylinder\u7b49\u6570\u5b66\u89c4\u5219\u8fdb\u884c\u62df\u5408","title":"\u57fa\u4e8e\u51e0\u4f55\u7279\u5f81"},{"location":"m%26l/segmentation/cloud-segmentation/#_3","text":"\u57fa\u4e8e\u5404\u79cd\u7279\u5f81\u53ca\u7ec4\u5408\u7279\u5f81\u7684\u533a\u57df\u589e\u957f(\u6b27\u5f0f\u8ddd\u79bb\u805a\u7c7b\u672c\u8d28\u4e3a\u533a\u57df\u589e\u957f,\u5224\u65ad\u6b27\u5f0f\u8ddd\u79bb)\u7b49\u3002 \u6838\u5fc3\u601d\u60f3\u5c31\u662f\u4ece\u4e00\u4e2a\u70b9\u51fa\u53d1,\u4f9d\u636e\u7ea6\u675f\u6761\u4ef6(\u8ddd\u79bb\u3001\u6cd5\u5411\u91cf\u3001\u5bc6\u5ea6\u5ea6\u91cf\u3001\u51f9\u51f8\u6027\u3001\u66f2\u7387\u7b49)\u6700\u7ec8\u589e\u957f\u6269\u6563\u4e3a\u4e00\u7c07 \u57fa\u672c\u6d41\u7a0b \u70b9\u4e91\u7279\u5f81","title":"\u533a\u57df\u589e\u957f(\u5e94\u7528\u5e7f\u6cdb\u3001\u6301\u7eed\u7814\u7a76\u4e2d)"},{"location":"m%26l/segmentation/cloud-segmentation/#_4","text":"\u57fa\u4e8e\u56fe\u8bba,\u5e94\u7528\u7f51\u7edc\u89c4\u5212,\u6c42\u89e3\u6865\u95ee\u9898,\u56fe\u50cf\u5206\u5272\u7b49\u9886\u57df,\u88ab\u79fb\u690d\u5230\u70b9\u4e91\u5206\u5272,\u70b9\u4e4b\u95f4\u8fde\u63a5\u4e3a\u56fe,\u8d4b\u4e88\u8fde\u7ebf\u6743\u503c,\u83b7\u5f97\u70b9\u4e4b\u95f4\u7684\u62d3\u6251\u5173\u7cfb\uff0c\u5206\u5272\u76ee\u6807\u9700\u8981\u4eba\u4e3a\u6307\u5b9a(\u5982\u6307\u5b9a\u4e86\u76ee\u6807\u7269\u4f53\u4e0a\u7684\u4e00\u4e2a\u70b9)!!!\u3002","title":"\u6700\u5c0f\u5206\u5272"},{"location":"m%26l/segmentation/cloud-segmentation/#_5","text":"\u822a\u7a7a\u6444\u5f71\u6d4b\u91cf\u4e2d\u4e3a\u53bb\u9664\u5730\u9762\u566a\u58f0\u5bf9\u5730\u5f62\u6d4b\u91cf\u7684\u5f71\u54cd,\u4e0d\u4f7f\u7528\u5730\u9762\u5e73\u6574\u5047\u8bbe\u7684\u524d\u63d0\u4e0b\u83b7\u5f97\u5730\u9762\u673a\u8f7dlidar \u6d4b\u91cf\u65b9\u5411\u548c\u5730\u9762\u5782\u76f4,\u5f62\u6210xy->z\u6620\u5c04(z\u65b9\u5411\u7684\u8303\u56f4\u8fdc\u8fdc\u5c0f\u4e8exy\u65b9\u5411),z\u65b9\u5411\u4ee3\u8868\u5730\u9762\u7269\u4f53\u7684\u9ad8\u5ea6,x,y\u65b9\u5411\u4e3a\u5e73\u884c\u4e0e\u5730\u9762\u4e14\u76f8\u4e92\u5782\u76f4\u7684\u4e24\u4e2a\u8f74","title":"\u57fa\u4e8e\u5f62\u6001\u5b66\u5206\u5272(\u56fe\u50cf\u5904\u7406\u7b97\u6cd5\u884d\u751f\u5230\u70b9\u4e91)"},{"location":"m%26l/segmentation/cloud-segmentation/#_6","text":"\u57fa\u4e8eOctree\u516b\u53c9\u6811\u5bf9\u70b9\u4e91\u8fdb\u884c\u5212\u5206\u5747\u5300\u5206\u5e03,\u83b7\u5f97\u4e0d\u540c\u70b9\u56e2\u4e4b\u95f4\u7684\u90bb\u63a5\u5173\u7cfb \u6240\u6709\u7684\u6676\u6838(seed)\u540c\u65f6\u5f00\u59cb\u751f\u957f,\u6700\u7ec8\u586b\u6ee1\u6574\u4e2a\u7a7a\u95f4\u5b8c\u6210\u5206\u5272,\u672c\u8d28\u8fd8\u662f\u57fa\u4e8e\u533a\u57df\u751f\u957f\u601d\u60f3\u3002 \u9996\u5148\u9700\u8981\u89c4\u5f8b\u7684\u5e03\u7f6e\u533a\u57df\u751f\u957f\u6676\u6838(\u6676\u6838\u5728\u7a7a\u95f4\u4e2d\u5b9e\u9645\u4e0a\u662f\u5747\u5300\u5206\u5e03), \u5e76\u6307\u5b9a\u6676\u6838\u8ddd\u79bb(Rseed),\u7c92\u5b50\u8ddd\u79bb(Rvoxel),\u6700\u5c0f\u6676\u7c92(MOV),\u8fc7\u5c0f\u7684\u6676\u7c92\u9700\u8981\u878d\u5165\u6700\u8fd1\u7684\u5927\u6676\u7c92 \u6709\u4e86\u6676\u6838(seed)\u548c\u7ed3\u6676\u8303\u56f4(\u641c\u7d22\u534a\u5f84)\u4e4b\u540e,\u7136\u540e\u63a7\u5236\u7ed3\u6676\u8fc7\u7a0b(\u589e\u957f\u7ea6\u675f\u6761\u4ef6)\u4ee5\u5b8c\u6210\u5206\u5272","title":"\u8d85\u4f53\u805a\u7c7b"},{"location":"m%26l/segmentation/cloud-segmentation/#lccplocally-convex-connected-pathches","text":"\u57fa\u4e8e\u8d85\u4f53\u805a\u7c7b\u5b9e\u73b0\u8fc7\u5206\u5272 \u57fa\u4e8e\u7a7a\u95f4\u4fe1\u606f\u548c\u6cd5\u7ebf\u4fe1\u606f,\u5728\u8d85\u4f53\u805a\u7c7b\u7684\u57fa\u7840\u4e0a\u518d\u805a\u7c7b\u53bb\u9664\u8fc7\u5206\u5272 \u5bf9\u4e8e\u8fc7\u5206\u5272\u7684\u70b9\u4e91\u8ba1\u7b97\u4e0d\u540c\u7684\u5757\u4e4b\u95f4\u51f9\u51f8\u5173\u7cfb\u5e76\u8bb0\u5f55,\u7136\u540e\u57fa\u4e8e\u533a\u57df\u589e\u957f\u5c06\u5c0f\u533a\u57df\u805a\u7c7b\u6210\u8f83\u5927\u7684\u7269\u4f53(\u53ea\u5141\u8bb8\u533a\u57df\u8de8\u8d8a\u51f8\u8fb9\u589e\u957f)","title":"LCCP(Locally Convex Connected Pathches)\u57fa\u4e8e\u8d85\u4f53\u805a\u7c7b(\u51f9\u51f8\u5173\u7cfb)"},{"location":"m%26l/segmentation/cloud-segmentation/#_7","text":"\u57fa\u4e8e\u865a\u62df\u56fe\u50cf\u5e73\u9762\u6295\u5f71 \u5c06\u70b9\u4e91\u6295\u5f71\u4e3arang-image/intensity-image\u57fa\u4e8e\u6fc0\u5149\u675f\u7279\u6027\u3001\u548c\u96f7\u8fbe\u81ea\u8eab\u53c2\u6570\u76f8\u5173 \u57fa\u4e8e2D-Grid\u5730\u9762\u65b9\u683c\u6216\u6781\u5750\u6807\u683c\u6295\u5f71(DAPAR\u6311\u6218\u8d5b\u4e2d\u5e7f\u6cdb\u4f7f\u7528) \u6295\u5f71\u52302D-grid raster\u53c2\u6570\u6839\u636e\u70b9\u4e91\u6570\u636e\u8c03\u6574,\u5355\u72ec\u4f7f\u7528\u5bb9\u6613\u5206\u5272\u4e0d\u8db3\u6216\u8fc7\u5206\u5272","title":"\u6295\u5f71\u65b9\u6cd5(\u7ef4\u5ea6\u635f\u5931)"},{"location":"m%26l/segmentation/cloud-segmentation/#_8","text":"3D grid+PointNet+3D CNN\u3001 MinCut\u3001KPCon\u3001 RS-CNN....\u8bed\u4e49\u5206\u5272 Hugues et al KPConv.arXiv 2019 pointpillar \u51c6\u786e\u7387\u3001\u53ec\u56de\u7387\u4e4b\u95f4\u8f83\u597d\u7684\u5e73\u8861","title":"\u6df1\u5ea6\u5b66\u4e60"},{"location":"math/vector_operation/","text":"note about operation of vector,such as dot and cross \u5411\u91cf\u70b9\u4e58 \u00b6 \u4e8c\u7ef4\u5411\u91cf $$ \\begin{aligned} \\mathbf{\\overrightarrow{a}} &= a_1\\mathbf{i}+a_2\\mathbf{j}\\\\ \\mathbf{\\overrightarrow{b}} &= b_1\\mathbf{i}+b_2\\mathbf{j} \\\\ \\mathbf{\\overrightarrow{a}}\\cdot\\mathbf{\\overrightarrow{b}} &= a_1b_1\\mathbf{i}+a_2b_2\\mathbf{j} \\end{aligned} \\tag{1} $$ \u4e09\u7ef4\u5411\u91cf $$ \\begin{aligned} \\mathbf{\\overrightarrow{a}} &= a_1\\mathbf{i}+a_2\\mathbf{j}+a_3\\mathbf{k}\\\\ \\mathbf{\\overrightarrow{b}} &= b_1\\mathbf{i}+b_2\\mathbf{j}+b_3\\mathbf{k} \\\\ \\mathbf{\\overrightarrow{a}}\\cdot\\mathbf{\\overrightarrow{b}} &= a_1b_1\\mathbf{i}+a_2b_2\\mathbf{j}+a_3b_3\\mathbf{k} \\end{aligned}\\tag{2} $$ \u5411\u91cf\u53c9\u4e58 \u00b6 \u4e09\u7ef4\u5411\u91cf $$ \\begin{aligned} \\mathbf{\\overrightarrow{a}} &= a_1\\mathbf{i}+a_2\\mathbf{j}+a_3\\mathbf{k}\\\\ \\mathbf{\\overrightarrow{b}} &= b_1\\mathbf{i}+b_2\\mathbf{j}+b_3\\mathbf{k} \\\\ \\mathbf{\\overrightarrow{a}}\\times\\mathbf{\\overrightarrow{b}} &= \\begin{bmatrix} \\mathbf{i} & \\mathbf{j}& \\mathbf{k}\\\\ a_1 & a_2 &a_3\\\\ b_1 & b_2 &b_3 \\end{bmatrix} \\\\ &= (a_2b_3 - a_3b_2)\\mathbf{i} + (a_3b_1 - a_1b_3)\\mathbf{j} + (a_1b_2 - a_2b_1)\\mathbf{k} \\\\ &= \\begin{bmatrix} a_2 & a_3 \\\\ b_2 & b_3 \\end{bmatrix}\\mathbf{i} + \\begin{bmatrix} a_3 & a_1 \\\\ b_3 & b_1 \\end{bmatrix}\\mathbf{j}+ \\begin{bmatrix} a_1 & a_2 \\\\ b_1 & b_2 \\end{bmatrix}\\mathbf{k} \\end{aligned}\\tag{3} $$ \u4e8c\u7ef4\u5411\u91cf $$ \\begin{aligned} \\mathbf{\\overrightarrow{a}} &= a_1\\mathbf{i}+a_2\\mathbf{j}\\\\ \\mathbf{\\overrightarrow{b}} &= b_1\\mathbf{i}+b_2\\mathbf{j} \\\\ \\mathbf{\\overrightarrow{a}}\\times\\mathbf{\\overrightarrow{b}} &= \\begin{bmatrix} \\mathbf{i} & \\mathbf{j}& \\mathbf{k}\\\\ a_1 & a_2 &0\\\\ b_1 & b_2 &0 \\end{bmatrix} \\\\ &= (a_1b_2 - a_2b_1)\\mathbf{k} \\\\ &= \\begin{bmatrix} a_1 & a_2 \\\\ b_1 & b_2 \\end{bmatrix}\\mathbf{k} \\end{aligned} \\tag{4} $$","title":"usage of vector's multi"},{"location":"math/vector_operation/#_1","text":"\u4e8c\u7ef4\u5411\u91cf $$ \\begin{aligned} \\mathbf{\\overrightarrow{a}} &= a_1\\mathbf{i}+a_2\\mathbf{j}\\\\ \\mathbf{\\overrightarrow{b}} &= b_1\\mathbf{i}+b_2\\mathbf{j} \\\\ \\mathbf{\\overrightarrow{a}}\\cdot\\mathbf{\\overrightarrow{b}} &= a_1b_1\\mathbf{i}+a_2b_2\\mathbf{j} \\end{aligned} \\tag{1} $$ \u4e09\u7ef4\u5411\u91cf $$ \\begin{aligned} \\mathbf{\\overrightarrow{a}} &= a_1\\mathbf{i}+a_2\\mathbf{j}+a_3\\mathbf{k}\\\\ \\mathbf{\\overrightarrow{b}} &= b_1\\mathbf{i}+b_2\\mathbf{j}+b_3\\mathbf{k} \\\\ \\mathbf{\\overrightarrow{a}}\\cdot\\mathbf{\\overrightarrow{b}} &= a_1b_1\\mathbf{i}+a_2b_2\\mathbf{j}+a_3b_3\\mathbf{k} \\end{aligned}\\tag{2} $$","title":"\u5411\u91cf\u70b9\u4e58"},{"location":"math/vector_operation/#_2","text":"\u4e09\u7ef4\u5411\u91cf $$ \\begin{aligned} \\mathbf{\\overrightarrow{a}} &= a_1\\mathbf{i}+a_2\\mathbf{j}+a_3\\mathbf{k}\\\\ \\mathbf{\\overrightarrow{b}} &= b_1\\mathbf{i}+b_2\\mathbf{j}+b_3\\mathbf{k} \\\\ \\mathbf{\\overrightarrow{a}}\\times\\mathbf{\\overrightarrow{b}} &= \\begin{bmatrix} \\mathbf{i} & \\mathbf{j}& \\mathbf{k}\\\\ a_1 & a_2 &a_3\\\\ b_1 & b_2 &b_3 \\end{bmatrix} \\\\ &= (a_2b_3 - a_3b_2)\\mathbf{i} + (a_3b_1 - a_1b_3)\\mathbf{j} + (a_1b_2 - a_2b_1)\\mathbf{k} \\\\ &= \\begin{bmatrix} a_2 & a_3 \\\\ b_2 & b_3 \\end{bmatrix}\\mathbf{i} + \\begin{bmatrix} a_3 & a_1 \\\\ b_3 & b_1 \\end{bmatrix}\\mathbf{j}+ \\begin{bmatrix} a_1 & a_2 \\\\ b_1 & b_2 \\end{bmatrix}\\mathbf{k} \\end{aligned}\\tag{3} $$ \u4e8c\u7ef4\u5411\u91cf $$ \\begin{aligned} \\mathbf{\\overrightarrow{a}} &= a_1\\mathbf{i}+a_2\\mathbf{j}\\\\ \\mathbf{\\overrightarrow{b}} &= b_1\\mathbf{i}+b_2\\mathbf{j} \\\\ \\mathbf{\\overrightarrow{a}}\\times\\mathbf{\\overrightarrow{b}} &= \\begin{bmatrix} \\mathbf{i} & \\mathbf{j}& \\mathbf{k}\\\\ a_1 & a_2 &0\\\\ b_1 & b_2 &0 \\end{bmatrix} \\\\ &= (a_1b_2 - a_2b_1)\\mathbf{k} \\\\ &= \\begin{bmatrix} a_1 & a_2 \\\\ b_1 & b_2 \\end{bmatrix}\\mathbf{k} \\end{aligned} \\tag{4} $$","title":"\u5411\u91cf\u53c9\u4e58"},{"location":"tools/mathjax/","text":"usage of mathjac \u5b57\u4f53 \u00b6 \u82b1\u4f53\u5b57\u6bcd \\(\\mathcal{H}\\) 1. \\(\\mathclap{R}\\) 2. \\(\\mathcal{R}\\) 3. \\(\\mathbin{R}\\) 4. \\(\\mathbf{R}\\) 5. \\(\\mathbb{R}\\) 6. \\(\\mathclose{R}\\) 7. \\(\\mathellipsis{R}\\) 8. \\(\\mathfrak{R}\\) 9. \\(\\mathinner{R}\\) 10. \\(\\mathit{R}\\) 11. \\(\\mathllap{R}\\) 12. \\(\\mathnormal{R}\\) \u6570\u5b66\u7b26\u53f7 1. \\(A^\\prime\\) \\[ \\theta_j = \\theta_j - \\alpha \\frac{\\partial}{\\partial\\theta_j}J(\\theta_0, \\theta_0) \\] \u7a7a\u683c \u00b6 info code 1cm\u5bbd\u5ea6 \\(a\\qquad b\\) 0.5cm \\(a\\quad b\\) \u2153cm \\(a\\ b\\) 2/7cm \\(a\\;b\\) \u2159cm \\(a\\,b\\) 0cm \u6b63\u5e38\u65e0\u7a7a\u683c \\(ab\\) \u7f29\u8fdb\u2159cm \\(a\\!b\\)","title":"usage of mathjax"},{"location":"tools/mathjax/#_1","text":"\u82b1\u4f53\u5b57\u6bcd \\(\\mathcal{H}\\) 1. \\(\\mathclap{R}\\) 2. \\(\\mathcal{R}\\) 3. \\(\\mathbin{R}\\) 4. \\(\\mathbf{R}\\) 5. \\(\\mathbb{R}\\) 6. \\(\\mathclose{R}\\) 7. \\(\\mathellipsis{R}\\) 8. \\(\\mathfrak{R}\\) 9. \\(\\mathinner{R}\\) 10. \\(\\mathit{R}\\) 11. \\(\\mathllap{R}\\) 12. \\(\\mathnormal{R}\\) \u6570\u5b66\u7b26\u53f7 1. \\(A^\\prime\\) \\[ \\theta_j = \\theta_j - \\alpha \\frac{\\partial}{\\partial\\theta_j}J(\\theta_0, \\theta_0) \\]","title":"\u5b57\u4f53"},{"location":"tools/mathjax/#_2","text":"info code 1cm\u5bbd\u5ea6 \\(a\\qquad b\\) 0.5cm \\(a\\quad b\\) \u2153cm \\(a\\ b\\) 2/7cm \\(a\\;b\\) \u2159cm \\(a\\,b\\) 0cm \u6b63\u5e38\u65e0\u7a7a\u683c \\(ab\\) \u7f29\u8fdb\u2159cm \\(a\\!b\\)","title":"\u7a7a\u683c"},{"location":"tools/python_matplotlib/","text":"\u4e3b\u8981\u8bb0\u5f55\u65e5\u5e38python\u4f7f\u7528\u7684matplotlib\u7ed8\u56fe\u65f6\u51fa\u73b0\u7684\u5e38\u89c1\u60c5\u51b5 matplotlib \u00b6 color table for reference \u00b6","title":"tools python-matploglib"},{"location":"tools/python_matplotlib/#matplotlib","text":"","title":"matplotlib"},{"location":"tools/python_matplotlib/#color-table-for-reference","text":"","title":"color table for reference"},{"location":"tools/tools-devel-environment/","text":"\u4f9d\u8d56\u5e93\u4e0b\u8f7d 1 2 3 4 5 6 #python wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz #google-series wget https://github.com/google/googletest/archive/release-1.8.0.tar.gz wget https://github.com/gflags/gflags/archive/v2.2.0.tar.gz wget https://github.com/google/glog/archive/v0.3.5.tar.gz","title":"tools devel-enviroment"},{"location":"tools/usage_bazel/","text":"Usage Bazel \u00b6 bazel build \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bazel build //main:hello-world bazel build //offboard/.../pose_graph_mapping:test #debug\u7f16\u8bd1 bazel build //offboard/mapping/pose_graph_mapping/lidar_odometry:pm_test --compilation_mode = dbg \\ -s \\ #-s\u663e\u793a\u7f16\u8bd1\u7ec6\u8282 --config = asan #\u7f16\u8bd1\u5668\u914d\u7f6e,\u7f16\u8bd1\u76f8\u5bf9\u8f83\u6162,\u76f4\u63a5\u8fd0\u884c\u7a0b\u5e8f\u4f1a\u63d0\u793a\u9519\u8bef\u4fe1\u606f(gdb\u542f\u52a8\u6b64\u65f6\u6ca1\u6709stack\u4fe1\u606f) #Run special GTest\"TEST(A, func1)\" ./bazel-bin/../test --gtest_filter = A.func1 bazel test ... -- -experimental/... bazel query //onboard/... | grep cpplint$ | xargs bazel test bazel query //offboard/... | grep cpplint$ | xargs bazel test - \u7f16\u8bd1\u5e76\u81ea\u52a8\u8fd0\u884c 1 2 3 4 5 6 7 8 9 bazel build -c dbg //offboard/mapping/pose_graph_mapping/lidar_odometry:pm_test bazel run -c opt offboard/mapping/pose_graph_mapping/match_visualization/match_visualization_main -- \\ --run_name = 20210513_101822_Q8007 --start_time = 3928 \\ --run_name2 = 20210514_160135_Q8007 --start_time2 = 1509 \\ --use_smooth \\ --map = wuhan_dongfeng \\ --read_params_from_txt_file = true \\ --gnss_strict_good \\ --vantage_server_addr = 0 .0.0.0:65001 #\u5148\u542f\u52a8vantage","title":"Usage Bazel"},{"location":"tools/usage_bazel/#usage-bazel","text":"","title":"Usage Bazel"},{"location":"tools/usage_bazel/#bazel-build","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bazel build //main:hello-world bazel build //offboard/.../pose_graph_mapping:test #debug\u7f16\u8bd1 bazel build //offboard/mapping/pose_graph_mapping/lidar_odometry:pm_test --compilation_mode = dbg \\ -s \\ #-s\u663e\u793a\u7f16\u8bd1\u7ec6\u8282 --config = asan #\u7f16\u8bd1\u5668\u914d\u7f6e,\u7f16\u8bd1\u76f8\u5bf9\u8f83\u6162,\u76f4\u63a5\u8fd0\u884c\u7a0b\u5e8f\u4f1a\u63d0\u793a\u9519\u8bef\u4fe1\u606f(gdb\u542f\u52a8\u6b64\u65f6\u6ca1\u6709stack\u4fe1\u606f) #Run special GTest\"TEST(A, func1)\" ./bazel-bin/../test --gtest_filter = A.func1 bazel test ... -- -experimental/... bazel query //onboard/... | grep cpplint$ | xargs bazel test bazel query //offboard/... | grep cpplint$ | xargs bazel test - \u7f16\u8bd1\u5e76\u81ea\u52a8\u8fd0\u884c 1 2 3 4 5 6 7 8 9 bazel build -c dbg //offboard/mapping/pose_graph_mapping/lidar_odometry:pm_test bazel run -c opt offboard/mapping/pose_graph_mapping/match_visualization/match_visualization_main -- \\ --run_name = 20210513_101822_Q8007 --start_time = 3928 \\ --run_name2 = 20210514_160135_Q8007 --start_time2 = 1509 \\ --use_smooth \\ --map = wuhan_dongfeng \\ --read_params_from_txt_file = true \\ --gnss_strict_good \\ --vantage_server_addr = 0 .0.0.0:65001 #\u5148\u542f\u52a8vantage","title":"bazel build"},{"location":"tools/usage_shortcut/","text":"usage of linux and vscode\u3001other common develop tools linux system \u00b6 vim(TODO,Need to test) \u00b6 Nowdays we spend a lot of time in bash shell, typing long and complex commands. You can use the arrow keys up/down/left/right to move the cursor and select commands, but that's not so efficient. | info | cmd | | :-------------------------- | :------------------------------------------------ | | Move in Charactor: back | C+b : Move back one charactor( C is for Ctrl ) | | Move in Charactor: forward | C+f : Move forward | | Move in Word: forward | Alt+f | | Move in Word: backward | Alt+b | | Move in Line: | | Terminator Shortcuts Usage \u00b6 shortcuts info ctrl+shift+o split windows horizontal ctrl+shift+e split windows vertical ctrl+shift+x switch between current window and all windows ctrl+shift+arrows move splitter bars of current working window alt+arrows switch between different working windows ctrl+shift+w close current window ctrl+shift+q close all window,that means close current terminator VsCode \u00b6 \u63d2\u4ef6\u4f7f\u7528\u53ca\u914d\u7f6e \u00b6 \u65e5\u5e38\u63d2\u4ef6 \u529f\u80fd \u914d\u7f6e\u53ca\u4f7f\u7528 Settings Sync \u5907\u4efdvscode\u914d\u7f6e\u53ca\u63d2\u4ef6 Sync Gist\u914d\u7f6e 1. GitHub GIST ID:vscode\u5185\u63d2\u4ef6setting (github gist repo\u7684url\u6570\u5b57\u90e8\u5206) 2. GitHub Token: /home/lyu/.config/Code/User/syncLocalSettings.json \u91cc\u9762token Upload: shift+alt+u Download:shift+alt+d ## Shortcuts Usage >\u8bbe\u7f6e\u4f4d\u7f6e: File->Preferences->Keyboard Shortcuts \u5e38\u7528\u8bbe\u7f6e info shortcuts \u6d3b\u52a8\u7a97\u53e3\u5207\u6362:view focus above editor group alt+i \u6d3b\u52a8\u7a97\u53e3\u5207\u6362:view focus below editor group alt+k \u6d3b\u52a8\u7a97\u53e3\u5207\u6362:view focus left editor group alt+j \u6d3b\u52a8\u7a97\u53e3\u5207\u6362:view focus right editor group alt+l \u7a97\u53e3\u5185\u6587\u4ef6\u5207\u6362:\u5de6\u4fa7\u6587\u4ef6 ctrl+pageUp \u7a97\u53e3\u5185\u6587\u4ef6\u5207\u6362:\u53f3\u4fa7\u6587\u4ef6 ctrl+pageDown \u5173\u95ed: \u5f53\u524d\u6587\u4ef6 ctrl+w \u5173\u95ed: vscode ctrl+shift+w go back alt+a go Forward alt+q page up alt+w page down alt+s cursor left ctrl+shift+j-useless cursor right ctrl+shift+l-useless cursor up ctrl+shift+i-useless cursor down ctrl+shift+k-useless cursorColumnSelectLeft alt+shift+j-useless cursorColumnSelectRight alt+shift+l-useless cursorColumnSelectUp alt+shift+i-useless cursorColumnSelectDown alt+shift+k-useless","title":"Shortcuts and Config Usage of linux and vscode"},{"location":"tools/usage_shortcut/#linux-system","text":"","title":"linux system"},{"location":"tools/usage_shortcut/#vimtodoneed-to-test","text":"Nowdays we spend a lot of time in bash shell, typing long and complex commands. You can use the arrow keys up/down/left/right to move the cursor and select commands, but that's not so efficient. | info | cmd | | :-------------------------- | :------------------------------------------------ | | Move in Charactor: back | C+b : Move back one charactor( C is for Ctrl ) | | Move in Charactor: forward | C+f : Move forward | | Move in Word: forward | Alt+f | | Move in Word: backward | Alt+b | | Move in Line: | |","title":"vim(TODO,Need to test)"},{"location":"tools/usage_shortcut/#terminator-shortcuts-usage","text":"shortcuts info ctrl+shift+o split windows horizontal ctrl+shift+e split windows vertical ctrl+shift+x switch between current window and all windows ctrl+shift+arrows move splitter bars of current working window alt+arrows switch between different working windows ctrl+shift+w close current window ctrl+shift+q close all window,that means close current terminator","title":"Terminator Shortcuts Usage"},{"location":"tools/usage_shortcut/#vscode","text":"","title":"VsCode"},{"location":"tools/usage_shortcut/#_1","text":"\u65e5\u5e38\u63d2\u4ef6 \u529f\u80fd \u914d\u7f6e\u53ca\u4f7f\u7528 Settings Sync \u5907\u4efdvscode\u914d\u7f6e\u53ca\u63d2\u4ef6 Sync Gist\u914d\u7f6e 1. GitHub GIST ID:vscode\u5185\u63d2\u4ef6setting (github gist repo\u7684url\u6570\u5b57\u90e8\u5206) 2. GitHub Token: /home/lyu/.config/Code/User/syncLocalSettings.json \u91cc\u9762token Upload: shift+alt+u Download:shift+alt+d ## Shortcuts Usage >\u8bbe\u7f6e\u4f4d\u7f6e: File->Preferences->Keyboard Shortcuts \u5e38\u7528\u8bbe\u7f6e info shortcuts \u6d3b\u52a8\u7a97\u53e3\u5207\u6362:view focus above editor group alt+i \u6d3b\u52a8\u7a97\u53e3\u5207\u6362:view focus below editor group alt+k \u6d3b\u52a8\u7a97\u53e3\u5207\u6362:view focus left editor group alt+j \u6d3b\u52a8\u7a97\u53e3\u5207\u6362:view focus right editor group alt+l \u7a97\u53e3\u5185\u6587\u4ef6\u5207\u6362:\u5de6\u4fa7\u6587\u4ef6 ctrl+pageUp \u7a97\u53e3\u5185\u6587\u4ef6\u5207\u6362:\u53f3\u4fa7\u6587\u4ef6 ctrl+pageDown \u5173\u95ed: \u5f53\u524d\u6587\u4ef6 ctrl+w \u5173\u95ed: vscode ctrl+shift+w go back alt+a go Forward alt+q page up alt+w page down alt+s cursor left ctrl+shift+j-useless cursor right ctrl+shift+l-useless cursor up ctrl+shift+i-useless cursor down ctrl+shift+k-useless cursorColumnSelectLeft alt+shift+j-useless cursorColumnSelectRight alt+shift+l-useless cursorColumnSelectUp alt+shift+i-useless cursorColumnSelectDown alt+shift+k-useless","title":"\u63d2\u4ef6\u4f7f\u7528\u53ca\u914d\u7f6e"},{"location":"tools/workspace_setup_ubuntu/","text":"Setup worksapce in ubuntu \u00b6 environment: ubuntu18.04 VPN \u00b6 v2ray(ref doc of yongcong) \u00b6 \u00b6 1 2 3 4 5 sudo apt install python3-pip sudo pip3 install shadowsocks #replace \"EVP_CIPHER_CTX_cleanup\" with \"EVP_CIPHER_CTX_reset\" of openssl.py by \":%s/old/new/g\" sudo vi /usr/local/lib/python3.8/dist-packages/shadowsocks/crypto/openssl.py sslocal -c shadowsocks_vpn_jikess.json the content of shadowsocks_vpn_jikess.json is: 1 2 3 4 5 6 7 8 { \"server\":\"tw-1.v2speed.net\", \"server_port\":13871, \"local_port\":1080, \"password\":\"4UlcsiptpO\", \"timeout\":600, \"method\":\"aes-256-cfb\" } vim \u00b6 vim\u9ed8\u8ba4\u663e\u793a\u884c\u6570\u8bbe\u7f6e /etc/vim/vimrc \u7684\u6700\u540e\u4e00\u884c\u52a0\u4e0a :set number vscode \u00b6 sync setting.json extensions.json keybindingsMac.json - \u5b89\u88c5\u63d2\u4ef6\u53caGoogle\u4ee3\u7801\u98ce\u683c\u4fdd\u5b58\u81ea\u52a8\u683c\u5f0f\u5316 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #************************* #@desc:c++ devel-env and autoformat by GoogleStyle #************************* #step1.install extensions:`C/C++\u3001Clang-Format\u3001` #step2.install executable clang-format sudo apt-get install clang-format #step3.config \"clang-format\" Settings\u641c\u7d22 \"clang-format\" ,\u914d\u7f6e \"Clang-format:Fallback Style\" \u4e3a \"Google\u5373\u53ef\" \"clang-format.fallbackStyle\" : \"Google\" #setting #step3.config autoformat when save the file #required: To automatically format a file on save, add the following to your vscode settings.json file \"editor.formatOnSave\" : true #optional: \"clang-format.executable\" : \"/absolute/path/to/clang-format\" - \u6dfb\u52a0\u5934\u6587\u4ef6\u8def\u5f84 \u6309F1\u6216 Ctrl+Shift+p \u5728\u5f39\u51fa\u7684\u5907\u9009\u9009\u9879\u4e2d\u9009\u62e9 C/C++:Edit Configuration(JSON)\uff0c\u81ea\u52a8\u6253\u5f00c_cpp_properties.json FAQ [ \u4ee3\u7801\u81ea\u52a8\u8df3\u8f6c\u5931\u8d25 ]\"Visual Studio Code is unable to watch for file changes in this large workspace\" solution /etc/sysctl.conf \u6587\u4ef6\u7684\u6700\u540e\u4e00\u884c\u52a0\u5165 fs.inotify.max_user_watches=524288 vscode\u7684\u6587\u4ef6\u76d1\u542c\u6570\u76ee,\u7136\u540e sudo sysctl -p \u91cd\u542f\u5373\u53ef \u81ea\u52a8\u8df3\u8f6c\u65e0\u6548 C/C++\u63d2\u4ef6\u8bbe\u7f6e \"C_Cpp.intelliSenseEngine\": \"Default\" , \u4e4b\u524d setting.json \u8bef\u64cd\u4f5c\u4e3aDisabled, fuck!!! git \u00b6 1 2 3 4 5 6 7 sudo apt install git # config git config --global user.name \"YongcongWang\" git config --global user.email \"yongcong.wang@outlook.com\" git config --global core.editor vim # generate key ssh-keygen -t rsa -C \"yongcong.wang@outlook.com\" Config \u00b6 Open github and sign in; In Settings/SSH and GPG keys click New SSH Key ; Paste id_rsa.PUB (in /home/.ssh/id_rsa.pub ); Test: ssh -T git@github.com .","title":"Setup worksapce in ubuntu"},{"location":"tools/workspace_setup_ubuntu/#setup-worksapce-in-ubuntu","text":"environment: ubuntu18.04","title":"Setup worksapce in ubuntu"},{"location":"tools/workspace_setup_ubuntu/#vpn","text":"","title":"VPN"},{"location":"tools/workspace_setup_ubuntu/#v2rayref-doc-of-yongcong","text":"","title":"v2ray(ref doc of yongcong)"},{"location":"tools/workspace_setup_ubuntu/#_1","text":"1 2 3 4 5 sudo apt install python3-pip sudo pip3 install shadowsocks #replace \"EVP_CIPHER_CTX_cleanup\" with \"EVP_CIPHER_CTX_reset\" of openssl.py by \":%s/old/new/g\" sudo vi /usr/local/lib/python3.8/dist-packages/shadowsocks/crypto/openssl.py sslocal -c shadowsocks_vpn_jikess.json the content of shadowsocks_vpn_jikess.json is: 1 2 3 4 5 6 7 8 { \"server\":\"tw-1.v2speed.net\", \"server_port\":13871, \"local_port\":1080, \"password\":\"4UlcsiptpO\", \"timeout\":600, \"method\":\"aes-256-cfb\" }","title":""},{"location":"tools/workspace_setup_ubuntu/#vim","text":"vim\u9ed8\u8ba4\u663e\u793a\u884c\u6570\u8bbe\u7f6e /etc/vim/vimrc \u7684\u6700\u540e\u4e00\u884c\u52a0\u4e0a :set number","title":"vim"},{"location":"tools/workspace_setup_ubuntu/#vscode","text":"sync setting.json extensions.json keybindingsMac.json - \u5b89\u88c5\u63d2\u4ef6\u53caGoogle\u4ee3\u7801\u98ce\u683c\u4fdd\u5b58\u81ea\u52a8\u683c\u5f0f\u5316 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #************************* #@desc:c++ devel-env and autoformat by GoogleStyle #************************* #step1.install extensions:`C/C++\u3001Clang-Format\u3001` #step2.install executable clang-format sudo apt-get install clang-format #step3.config \"clang-format\" Settings\u641c\u7d22 \"clang-format\" ,\u914d\u7f6e \"Clang-format:Fallback Style\" \u4e3a \"Google\u5373\u53ef\" \"clang-format.fallbackStyle\" : \"Google\" #setting #step3.config autoformat when save the file #required: To automatically format a file on save, add the following to your vscode settings.json file \"editor.formatOnSave\" : true #optional: \"clang-format.executable\" : \"/absolute/path/to/clang-format\" - \u6dfb\u52a0\u5934\u6587\u4ef6\u8def\u5f84 \u6309F1\u6216 Ctrl+Shift+p \u5728\u5f39\u51fa\u7684\u5907\u9009\u9009\u9879\u4e2d\u9009\u62e9 C/C++:Edit Configuration(JSON)\uff0c\u81ea\u52a8\u6253\u5f00c_cpp_properties.json FAQ [ \u4ee3\u7801\u81ea\u52a8\u8df3\u8f6c\u5931\u8d25 ]\"Visual Studio Code is unable to watch for file changes in this large workspace\" solution /etc/sysctl.conf \u6587\u4ef6\u7684\u6700\u540e\u4e00\u884c\u52a0\u5165 fs.inotify.max_user_watches=524288 vscode\u7684\u6587\u4ef6\u76d1\u542c\u6570\u76ee,\u7136\u540e sudo sysctl -p \u91cd\u542f\u5373\u53ef \u81ea\u52a8\u8df3\u8f6c\u65e0\u6548 C/C++\u63d2\u4ef6\u8bbe\u7f6e \"C_Cpp.intelliSenseEngine\": \"Default\" , \u4e4b\u524d setting.json \u8bef\u64cd\u4f5c\u4e3aDisabled, fuck!!!","title":"vscode"},{"location":"tools/workspace_setup_ubuntu/#git","text":"1 2 3 4 5 6 7 sudo apt install git # config git config --global user.name \"YongcongWang\" git config --global user.email \"yongcong.wang@outlook.com\" git config --global core.editor vim # generate key ssh-keygen -t rsa -C \"yongcong.wang@outlook.com\"","title":"git"},{"location":"tools/workspace_setup_ubuntu/#config","text":"Open github and sign in; In Settings/SSH and GPG keys click New SSH Key ; Paste id_rsa.PUB (in /home/.ssh/id_rsa.pub ); Test: ssh -T git@github.com .","title":"Config"}]}